#!/bin/sh /etc/rc.common
# Copyright (C) 2006 OpenWrt.org

START=47

debug_route=0
route_log_file=/tmp/route.log

[ -f /tmp/debug_route ] && {
  debug_route=1
  echo "route[$0 $@] started at $(date)" >> $route_log_file
}

dbg_log() {
  [ $debug_route = 1 ] && echo "$@" >> $route_log_file
}

load_routes() {

	count=`uci get route.general.routes_count`
	i=0
	while [ $i -lt $count ]
	do

		new=`uci get route.@route[$i].new`
		delete=`uci get route.@route[$i].delete`
		dst=`uci get route.@route[$i].dest_ip`
		mask=`uci get route.@route[$i].netmask`
		gateway=`uci get route.@route[$i].gateway`
                enable=`uci get route.@route[$i].enable`
                type=`uci get route.@route[$i].type`

		if [ "$delete" = "1" ] ; then
			dbg_log "route del -net $dst netmask $mask gw $gateway"
			route del -net $dst netmask $mask gw $gateway||echo "Failed to delete route"
			uci del route.@route[$i]

			count=`expr $count - 1`
           		uci set route.general.routes_count=$count

                        continue
		fi

	        # check if we need to re-add the entry
		if ! netstat -rn | grep -q "^$dst[[:space:]]*$gateway[[:space:]]*$mask[[:space:]]"; then
		   new=1
		fi

                if [ "$new" = "0" ] && [ "$enable" = "0" ]; then
                    dbg_log "route del -net $dst netmask $mask gw $gateway"
	  	    route del -net $dst netmask $mask gw $gateway
                    if [ $? -eq 0 ] ; then
                          uci set route.@route[$i].new=1
                          uci set route.@route[$i].status=Disabled
                    else
                          uci set route.@route[$i].new=0
                          uci set route.@route[$i].status=Enabled
			  echo "Failed to delete route"
                    fi
                fi

		if [ "$new" = "1" ] && [ "$enable" = "1" ] ; then
                        if [ $type == "Default" ] ; then
                          route add default gw $gateway metric 1
                        elif [ $type == "Network" ] ; then
                           route add -net $dst netmask $mask gw $gateway           
                        elif [ $type == "Host" ] ; then
                           route add -host $dst gw $gateway metric 1
                        else
                          uci set route.@route[$i].type=Network
                          route add -net $dst netmask $mask gw $gateway metric 1      
                        fi

                        if [ $? -eq 0 ] ; then
                          uci set route.@route[$i].new=0
                          uci set route.@route[$i].status=Enabled
                        else
                          uci set route.@route[$i].new=1
                          uci set route.@route[$i].status=Error
                          echo "Failed to add route"
                        fi
		fi

		i=`expr $i + 1`
	done        
}

restart() {
    reload
}

reload() {
    dbg_log "Reload function started"
    
    #we can't return if nothing changed in here. The time when this script
    #was executed(at boot) the interfaces may not have been ready and added routes failed. 
    # To fix that issue the script may have been triggered from hotplug event, 
    #without any change on the route structure
    
    #load static routes
    dbg_log "load static routes"
    load_routes
    
    #fixup source based routing entries
    dbg_log "load source based rules"
    route.sh
    
    return 0
}

start () {
    load_routes

    #fixup source based routing entries. Most of the times this is not necessary at boot.
    #The routing will be updated through a hotplug event, this is true except when a static interface
    #has been applied on non volatile storage(i.e. no dhcp).
    route.sh

}

stop () {
    true
}
