#!/bin/sh /etc/rc.common

# Copyright (c) 2011 PacketFront International AB. All rights reserved.
#
# This Software and its content are protected by the Swedish Copyright Act
# (Sw: Upphovsr<E4>ttslagen) and, if applicable, the Swedish Patents Act
# (Sw: Patentlagen). All and any copying and distribution of the software
# and its content without authorization by PacketFront International AB is
# prohibited. The prohibition includes every form of reproduction and
# distribution.
#
# Author: pierre ingelfeldt
#

START=46
STOP=54

. /lib/firewall/iptlib
. /etc/functions.sh

###############################################################
      ## local dubug prints##
##############################################################
debug_acl=0
acl_log_file=/tmp/firewall/acl.log

[ -f /tmp/debug_acl ] && {
    debug_acl=1
    [ -d /tmp/firewall ] || mkdir /tmp/firewall
    local msg="acl[$0 $@] started at $(date)"
    
    logger -s -t acl -p daemon.debug "$msg"
    echo "$msg" >> $acl_log_file
}

acl_dbg_log() {
    [ $debug_acl = 1 ] && { 
	local date=`date +%s`
	local msg="$@"
	msg="${date}: ${msg}"
	logger -s -t acl -p daemon.debug "${msg}"
	echo "$msg" >> $acl_log_file
    }
}


###############################################################
      ## UCI default config##
##############################################################
set_default_config()
{
    #stored in acl.config
    /sbin/uci setdefault /etc/config/acl.acl=acl
}


###############################################################
      ## ACL helper functions ##
##############################################################

#arg1 acl entry name
#arg2 chain
#example use: acl_add_rule my-acl20 INPUT
acl_add_rule()
{
    local type=""
    local srcaddr=""
    local srcprefix=""
    local protocol=""
    local entryname=""
    local seq=""
    local chain=""

    entryname=$1
    chain=$2

    [ -z "$entryname" -o -z "$chain" ] && {
	acl_dbg_log "acl_load_ip_rule error, not an argument"
	return
    }
    config_get seq $entryname seq
    config_get type $entryname type
    config_get permission $entryname permission
    config_get srcaddr $entryname srcaddr
    config_get srcprefix $entryname srcprefix
    config_get dstaddr $entryname dstaddr
    config_get dstprefix $entryname dstprefix
    config_get srcport $entryname srcport
    config_get dstport $entryname dstport
    config_get protocol $entryname protocol
    config_get flags $entryname flags
    config_get notification $entryname notification
    
    case $type in
        "ip" )
            acl_dbg_log "ipt_rule_add_ip $chain $permission $srcaddr $srcprefix $dstaddr $dstprefix $protocol"
	    ipt_rule_add_ip "$chain" "$permission" "$srcaddr" "$srcprefix" "$dstaddr" "$dstprefix" "$protocol" 
	    ;;
        "udp")
            acl_dbg_log "ipt_rule_add_udp $chain $permission $srcaddr $srcprefix $srcport $dstaddr $dstprefix $dstport"
	    ipt_rule_add_udp "$chain" "$permission" "$srcaddr" "$srcprefix" "$srcport" "$dstaddr" "$dstprefix" "$dstport" 
	    ;;
        "tcp")
            acl_dbg_log "ipt_rule_add_tcp $chain $permission $srcaddr $srcprefix $srcport $dstaddr $dstprefix $dstport $flags"
	    ipt_rule_add_tcp "$chain" "$permission" "$srcaddr" "$srcprefix" "$srcport" "$dstaddr" "$dstprefix" "$dstport" "$flags" 
	    ;;
        "icmp" )
            acl_dbg_log "ipt_rule_add_icmp $chain $permission $srcaddr $srcprefix $dstaddr $dstprefix $notification"
	    ipt_rule_add_icmp "$chain" "$permission" "$srcaddr" "$srcprefix" "$dstaddr" "$dstprefix" "$notification"
	    ;;
        * )
            acl_dbg_log "Error entry type not supported!!" ;;
    esac
}


###############################################################
      ## ACL process ##
##############################################################

#this is the core function in the ACL process and will do the actual kernel 
#configuration out of UCI structures. The function is executed by ma and when anything has changed 
#in the ACL structures. Note that this script has be executed after the network script has been 
#executed(if needed). Otherwise ACL's may not been deleted from the interfaces. The function use the 
#iptlib script(iptables wrapper) for all iptable configd
#Flow diagram:
#
# - load acl config
# - read all sections out of the acl config, and create a lists of access-lists e.g. -> created_lists="my-acl_x my-acl_y my-acl_z" 
# - create a sorted list of the sequence numbers of each access list, e.g. acls=10 23 50 90 for the my-acl_x list. 
# - Rename the implemented chain if any! Note that the name of the chain is the name of the access-list and that the renamed 
#   chain is _<access-list-name>, e.g. my-acl_x -> _my-acl_x
# - Create a new chain and add rules from the UCI structures in the sequence order.
# - load network config
# - Loop through the interfaces and find all interfaces where a access-list may be applied (input or/and output)
# - Insert a access list on input or/and output if true. Note that the rule may be the first or second on this particular interface
# - Clean up iptables! remove old rules applied on interfaces and old not used chains!

acl_process() {

    acl_dbg_log "acl_process" 
    config_load acl

    #Apply new chains 
    g_iptchains=
    for section in $CONFIG_SECTIONS; do
	config_get iptname $section name
	ipt_filter_name "$iptname"
	iptname="$filter"
	[ -z "$iptname" ] && continue
	acl_dbg_log "process acl entry $section"
        #check if already created
	iscreated=
	for val in $g_iptchains; do
	    [ "$iptname" = "$val" ] && iscreated=true
	done
        #create a sorted list of sequens numbers for that access list
	[ -z "$iscreated" ] && {
	    acl_dbg_log "create a sorted list for $iptname "
	    g_iptchains="$g_iptchains $iptname"
	    #create a list of sequence numbers for that acl
	    seqs=
	    for val in $CONFIG_SECTIONS; do
		config_get name $val name
		ipt_filter_name "$name"
		name="$filter"
		[ "$name" = "$iptname" ] && {
		    config_get seq $val seq
		    seqs="$seqs $seq"
		}
	    done
	    #sort
	    seqs=`echo $seqs | tr " " "\n" | sort -n | tr "\n" " "`
	    acl_dbg_log "sorted number $iptname: $seqs"
            #create chain
	    acl_dbg_log "ipt_chain_rename $iptname ..$iptname"
	    ipt_chain_rename "$iptname" "..$iptname"
	    acl_dbg_log "ipt_chain_create $iptname"
	    ipt_chain_create "$iptname"
	    ipt_chain_flush "$iptname"
	    for seq in $seqs; do
		for val in $CONFIG_SECTIONS; do
		    config_get _seq $val seq
		    if [ "$seq" = "$_seq"  ]; then
			config_get name $val name
			ipt_filter_name "$name"
			name="$filter"
			[ "$name" = "$iptname" ] && {
			    acl_dbg_log "acl_add_rule $section $iptname"
			    acl_add_rule "$val" "$iptname"
			}
		    fi
		done
	    done
	    #Last rule in the chain is LOGDROP
	    ipt_rule_add "-A $iptname -j LOGDROP"
	}
    done

    #check if any interfaces has changed
    #if [ -z "$APPLY_CHANGES" ] || [ -n "$CHANGED_network" ];then
	inrulenum=0
	outrulenum=0
        #loop through the interfaces and apply chains on INPUT and OUTPUT chains for the corresponding interface
	config_load network
	acl_dbg_log "Loop through interfaces and apply chains to interfaces"
	for dev in $CONFIG_SECTIONS;do
	    if [ -n CHANGED_network_$dev -o -z "$APPLY_CHANGES" ]; then
		config_get acl_in $dev acl_in
		config_get acl_out $dev acl_out		
		#convert
		ipt_filter_name "$acl_in"
		acl_in="$filter"
		ipt_filter_name "$acl_out"
		acl_out="$filter"

                #find the interface
		proto=
		iface=
		config_get proto $dev proto
		config_get iface $dev ifname
		[ "$proto" = "pppoe" ] && {
                    # force changing physical interface name to ppp0 when PPPoE is running
                    # but the interface is not up yet
                    # TODO: this needs to be redesigned if we support running PPPoE on
                    # multiple interfaces
		    echo $iface | grep "ppp[0-9]" || {
			iface="ppp0"
		    }
		}
		
                #INPUT chain
		if [ -n "$acl_in" ]; then
		    acl_dbg_log "ipt_chain_insert .input_acl $acl_in $iface "
		    ipt_chain_insert ".input_acl" "$acl_in" "$iface" ""
		    let inrulenum=$inrulenum+1
		fi
                #OUTPUT chain
		if [ -n "$acl_out" ]; then
		    acl_dbg_log "ipt_chain_insert .output_acl $acl_out  $iface"
		    ipt_chain_insert ".output_acl" "$acl_out" "" "$iface"
		    let outrulenum=$outrulenum+1
		fi
	    fi
	done

        #remove old rules from the input_acl chain
	let rulenum=$inrulenum+1
	while [ $? -eq 0 ]; do
	    ipt_rulenum_delete .input_acl "$rulenum"
	done
	
        #remove old rules from the output_acl chains
	let rulenum=$outrulenum+1
	while [ $? -eq 0 ]; do
	    ipt_rulenum_delete .output_acl "$rulenum"
	done

    #fi

    
    #remove deleted chains
    for acl in $OLD_acl_CONFIG_SECTIONS; do
	ret=`echo " $NEW_acl_CONFIG_SECTIONS " | grep " $acl "`
	[  -n "$ret" ] || {
	    eval name=\$"OLD_acl_${acl}_name"
	    ret=`echo " $g_iptchains " | grep " $name "`
	    [  -n "$ret" ] || {
		ipt_filter_name "$name"
		name="$filter"
		acl_dbg_log "ipt_chain_delete $name"
		ipt_chain_delete "$name"
	    }
	}
    done
    
    #remove renamed changed
    for acl in $g_iptchains; do
	acl_dbg_log "ipt_chain_delete ..$acl"
	ipt_chain_delete "..$acl"
    done
    
    return 0
}


reload() {
    acl_process
}

start() {		    
    acl_process
}

restart() {
    acl_process
}

stop()
{
    true
}
