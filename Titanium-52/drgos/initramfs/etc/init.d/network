#!/bin/sh /etc/rc.common
# Copyright (C) 2006 OpenWrt.org

debug_network=0
network_log_file=/tmp/network.log

[ -f /tmp/debug_network ] && {
  debug_network=1
  local msg="network[$0 $@] started at $(date)"

  logger -s -t network -p daemon.debug "$msg"
  echo "$msg" >> $network_log_file
}

dbg_log() {
  [ $debug_network = 1 ] && { 
    local date=`date +%s`
    local msg="$@"
    msg="${date}: ${msg}"
    logger -s -t network -p daemon.debug "${msg}"
    echo "$msg" >> $network_log_file
  }
}

START=44
STOP=44

#include support for config_ commands
. /etc/functions.sh

#include support acl's
. /lib/firewall/iptlib

set_default_config()
{
  local uci_confdir="/etc/config/"
  local cfg="network"
  local wanmac=""

  [ -s "/etc/config/usp" ] && wanmac=`uci get usp.eth.ethaddr`
  [ "$(echo ${#wanmac})" = "17" ] || wanmac="00:ED:CD:EF:AA:CC"
  local lanmac=${wanmac:0:16}1

  /sbin/uci setdefault $uci_confdir/$cfg.default="global"
  /sbin/uci setdefault $uci_confdir/$cfg.default.wan_if="vlan1"
  /sbin/uci setdefault $uci_confdir/$cfg.default.lan_ip="192.168.1.254/24"

  /sbin/uci setdefault $uci_confdir/$cfg.loopback="interface"
  /sbin/uci setdefault $uci_confdir/$cfg.loopback.ifname="lo"
  /sbin/uci setdefault $uci_confdir/$cfg.loopback.proto="static"
  /sbin/uci setdefault $uci_confdir/$cfg.loopback.ipaddr="127.0.0.1"
  /sbin/uci setdefault $uci_confdir/$cfg.loopback.netmask="255.0.0.0"

  /sbin/uci setdefault $uci_confdir/$cfg.wan="interface"
  /sbin/uci setdefault $uci_confdir/$cfg.wan.ifname="eth0"
  /sbin/uci setdefault $uci_confdir/$cfg.wan.proto="no"
  /sbin/uci setdefault $uci_confdir/$cfg.wan.macaddr=$wanmac
  /sbin/uci setdefault $uci_confdir/$cfg.wan.last_connection_error="ERROR_NONE"
  /sbin/uci setdefault $uci_confdir/$cfg.wan.keepalive=""
  /sbin/uci setdefault $uci_confdir/$cfg.wan.mtu=""
  /sbin/uci setdefault $uci_confdir/$cfg.wan.disabled="0"

  /sbin/uci setdefault $uci_confdir/$cfg.vlan1="interface"
  /sbin/uci setdefault $uci_confdir/$cfg.vlan1.ifname="eth0.1"
  /sbin/uci setdefault $uci_confdir/$cfg.vlan1.proto="dhcp"
  /sbin/uci setdefault $uci_confdir/$cfg.vlan1.macaddr=$wanmac
  /sbin/uci setdefault $uci_confdir/$cfg.vlan1.last_connection_error="ERROR_NONE"
  /sbin/uci setdefault $uci_confdir/$cfg.vlan1.keepalive=""
  /sbin/uci setdefault $uci_confdir/$cfg.vlan1.mtu=""
  /sbin/uci setdefault $uci_confdir/$cfg.vlan1.disabled="0"

  /sbin/uci setdefault $uci_confdir/$cfg.lan="interface"
  /sbin/uci setdefault $uci_confdir/$cfg.lan.type="bridge"
  /sbin/uci setdefault $uci_confdir/$cfg.lan.ifname="eth2"
  /sbin/uci setdefault $uci_confdir/$cfg.lan.proto="static"
  /sbin/uci setdefault $uci_confdir/$cfg.lan.ipaddr="192.168.1.254"
  /sbin/uci setdefault $uci_confdir/$cfg.lan.netmask="255.255.255.0"
  /sbin/uci setdefault $uci_confdir/$cfg.lan.macaddr=$lanmac
  /sbin/uci setdefault $uci_confdir/$cfg.lan.disabled="0"
  /sbin/uci setdefault $uci_confdir/$cfg.lan.igmprobustness="2"
  /sbin/uci setdefault $uci_confdir/$cfg.lan.igmpfastleave="0"
  #To simplify and prepare for future support of multiple
  #downstream interfaces, define lan as downstream
  /sbin/uci setdefault $uci_confdir/$cfg.lan.downstream="1"

  wifi config
}

br_del ()
{
    dev=$1

    FILES=/sys/class/net/br-${dev}/brif/*
    for f in $FILES
    do
	f=`echo ${f##*/}`
	dbg_log "delete if: brctl delif br-${dev} $f"
	brctl delif "br-${dev}" "$f" 2>/dev/null >/dev/null
    done
    
    dbg_log "delete bridge:  brctl delbr br-${dev}"
    brctl delbr "br-${dev}" >/dev/null 2>/dev/null
    
}

reload_services()
{
  # reload sipapp
  local reload_sipapp=0
  local src_intf_signal=$(uci -q get sip.global.signal_interface)
  local src_intf_media=$(uci -q get sip.global.media_interface)

  [ -n "$src_intf_signal" ] && {
    local changed=$(env|grep "CHANGED_network_$src_intf_signal=")
    [ -n "$changed" ] && reload_sipapp=1
  }

  if [ $reload_sipapp -eq 0 ] && [ -n "$src_intf_media" ]; then
    local changed=$(env|grep "CHANGED_network_$src_intf_media=")
    [ -n "$changed" ] && reload_sipapp=1
  fi

  [ $reload_sipapp -eq 1 ] && /etc/init.d/sip reload

}

#arg1: ifaces, arg2: add/del
#The function will try to add the interface to the MSP 5 times. Usually
# it succeedes on first or second try
cmm_vlan()
{
    ifs=$1
    if [ "$2" = "add" ]; then
	for if in $ifs; do
	    dbg_log "$if in $ifaces"
	    cvlan=
	    if [ $if != ${if##*eth0.} ] && [ $if != ${if##_} ]; then
		for i in 1 2 3 4 5;do
		    cmm -c vlan add $if >/dev/null 2>&1
		    dbg_log "cmm -c vlan add $if"
		    cvlan=`cmm -c vlan show | grep "${if},"`
		    [ -n "$cvlan" ] && break;
		    dbg_log "interface not created, retry"
		    sleep 1
		done
	    fi  
	done
    else
	for if in $ifs; do                   
            if [ $if != ${if##*eth0.} ]; then
		cmm -c vlan del $if >/dev/null 2>&1              
		dbg_log "cmm -c vlan del $if"          
	    fi
	done      
    fi
}

DHCP_OPTS_FILE="/tmp/dhcp_opts_file"
DHCP_OPT_INHER_FILE="/tmp/dhcp_opt_inher_file"
load()
{
  dbg_log "load function started"

  config_load network
  
  dbg_log "loop on $CONFIG_SECTIONS and delete/disable interfaces"
  #Find all interfaces that should be deleted or disabled
  #About "dev_delete", the loop will load this var with dev's that should be deleted. "config_clear"
  #can't handle indexes why deletion has to be done outside the loop. e.g. "config_clear vlan100"
  #will also delete vlan100_1. This fix #22403.
  dev_delete=
  for dev in $CONFIG_SECTIONS; do
      
      id=`echo ${dev##vlan}`

      [ "$id" == "$dev" ] && continue
      
      config_get ifname $dev ifname
      if echo "$ifname" | grep -q "ppp"; then
	  config_get device $dev device
	  [ -n "$device" ] && ifname="$device"
      fi
      
      config_get delete $dev delete
      config_get_bool bvlan_disabled $dev disabled 0
      dbg_log "delete=$delete bvlan_disabled=$bvlan_disabled dev=$dev"
      if [ "$delete" == "1" ] || [ "$bvlan_disabled" = "1" ]; then	  
	  #delete the interface in the MSP 
	  cmm_vlan $ifname "del" 

	  ifdown "$dev"
	  dbg_log "ifdown $dev"
	  [ "$delete" == "1" ] && {
	      #delete acl's, has to be done in network script before the UCI structure is deleted
	      config_get acl_in $dev acl_in
	      config_get acl_out $dev acl_out
	      [ -n "$acl_in" ] && {
		  dbg_log "ipt_rule_delete .input_acl $ifname $acl_in "
		  ipt_rule_delete .acl_input $ifname "" $acl_in
	      }
	      [ -n "$acl_out" ] && {
		  dbg_log "ipt_rule_delete .output_acl $ifname $acl_out "
		  ipt_rule_delete .output_acl "" $ifname $acl_out
	      }
	      #delete uci
	      dev_delete="$dev_delete $dev"
	  }

	  #Remove the interfaces from linux if not a child interface. Child interfaces are removed
	  # when parent is deleted
	  #TODO compatible with PPP?????
	  [ "$ifname" = "${1%\_*}" ] || vconfig rem "$ifname"
      fi  
  done
  
  #Fix #22403, as described above
  for dev in $dev_delete; do
      dbg_log "uci del network.$dev"
      config_clear $dev
      uci del network.$dev
  done

  dbg_log "[loop] delete/disable interfaces done"
  

  #reload network params after the removal of interfaces
  config_load network
    
  config_get_bool blan_disabled lan disabled 0
  config_get_bool bwan_disabled wan disabled 0


  #restart switch which is required if new
  #NAT output interface has been defined. The switch
  #script will enable forwarding on NAT output interface.
  dbg_log "restart switch"
  /etc/init.d/switch restart
 
  [ -n "$APPLY_CHANGES" -a -z "$CHANGED_network_loopback" ] || {
      dbg_log "ifup loopback"
      ifup loopback
  }
  if [ "$bwan_disabled" = "1" ]; then
      dbg_log "ifdown wan"
      ifdown wan
  else
      if [ -z "$APPLY_CHANGES" ] || [ -n "$CHANGED_network_wan" ];then
          dbg_log "ifup wan"
          ifup wan
      fi
  fi
  
  if [ "$blan_disabled" = "1" ]; then
      dbg_log "ifdown lan"
      wifi down
      ifdown lan

      #remove the bridge if disabled
      br_del "lan"
  else
      [ -n "$APPLY_CHANGES" -a -z "$CHANGED_network_lan" -a -z "$CHANGED_wireless" ] || {
          dbg_log "ifup lan"
          ifup lan
	  wifi up
      }
  fi
  
  dbg_log "loop through $CONFIG_SECTIONS and enable enabled interfaces"
  #find all vlans and reload if required 
  for dev in $CONFIG_SECTIONS; do
      config_get_bool dev_disabled $dev disabled 0
      config_get dwnstr $dev downstream
      if [ "$dev_disabled" != "1" ] && [ "$dwnstr" != "1" ] && [ "${dev##*vlan}" != "$dev" ]; then
	  ifchanged=$(env | grep CHANGED_network_$dev)
	  [ -n "$APPLY_CHANGES" -a -z "$ifchanged" ] || {
	      dbg_log "ifup $dev"
              ifup $dev
	  }
      fi

      #remove down stream interface in Linux for 1.6.1 
      #according to IP
      [ "$dwnstr" == "1" ] && {
	  config_get ifname $dev ifname
	  [ "$ifname" = "${1%\_*}" ] || vconfig rem "$ifname"
      }
  done
  dbg_log "[loop] change interfaces done"
  

  #This is a fix for Bug #24412: Static route in startup-config not applied after bootup!
  #The root cause of this bug is that the interface may not be ready even though the 
  #"ifup" function returns. This may generate failures in apply scripts executed after 
  #this script, e.g. route. The interface check below will make sure the IP is configured
  #on all static configured vlan interfaces. The loop counter 5 is based on the maximum time
  #a interface may take to be created with a high CPU load.

  #Note, tasks have been added to fix this issue in a more proper way, 
  #i.e. mgmt error handling and router daemon!
  for dev in $CONFIG_SECTIONS; do       
      config_get proto $dev proto
      if [ "$proto" = "static" ] && [ "${dev##*vlan}" != "$dev" ]; then
	  config_get iface $dev ifname
	  config_get ipaddr $dev ipaddr
	  for i in 1 2 3 4 5;do
	      addr=`ifconfig $iface | grep 'inet addr:' | cut -d: -f2 | cut -d' ' -f1`
	      dbg_log "iface $iface is up, ipaddr=$ipaddr:addr=$addr?"
	      if [ "$addr" = "$ipaddr" ]; then
		  break
	      else
		  dbg_log "puh, sleep a while"
		  sleep 1
	      fi
	  done
      fi
  done
  
  #disable forwarding on all interfaces except
  #lan, nat external and igmp external
  config_get natext lan natexternaliface
  config_get igmpext lan igmpupstreamintf
  fwlist=
  dbg_log "Test forwarding"
  for dev in $CONFIG_SECTIONS; do
      config_get_bool dev_disabled $dev disabled 0
      dbg_log "enabled $dev?"
      if [ "$dev_disabled" != "1" ] && [ "${dev##*vlan}" != "$dev" ]; then
	  dbg_log "Not a nat or igmp interface $dev"
	  if [ "$dev" != "$natext" ] && [ "$dev" != "$igmpext" ];then
	      dbg_log "disable forw on $dev"
	      config_get ifname $dev ifname
	      fwlist="$fwlist $ifname" 
	  fi
      fi
  done  
  dbg_log "disable forwarding on following interfaces: $fwlist"
  vlan-ipforwarding "$fwlist"

  #sync L3 vlan interfaces to the MSP
  dbg_log "start vlan sync to MSP"
  for dev in $CONFIG_SECTIONS; do       
      #msp
      proto=
      config_get proto $dev proto
      if [ "$proto" = "dhcp" ] || [ "$proto" = "static" ]; then
	  ifaces=
	  config_get ifaces $dev ifname
	  dbg_log "$dev: $ifaces"
	  cmm_vlan "$ifaces" "add"
      fi      
  done

  dbg_log "load function completed"
  return 0
}

reload()
{
  dbg_log "Reload function started"

  # Don't bring up interfaces when LAN1 and LAN2 are looped back otherwise the
  # system may crash
  [ -f /var/lock/upgrading_firmware ] && {
    dbg_log "A firmware upgrade is ongoing, exited"
    return 0
  }

  # return immediately if nothing changed
  [ -n "$APPLY_CHANGES" -a -z "$CHANGED_network" ] && {
    dbg_log "Nothing changed, exited"
    return 0
  }

  # set change flag to an interface if DHCP inheritance options are changed and
  # the source interface is set to this interface
  [ -n "$APPLY_CHANGES" -a -n "$CHANGED_network_dhcpc" ] && {
    local iface="$NEW_network_dhcpc_source_interface"
    [ -z "$iface" ] && {
      [ -f $DHCP_OPTS_FILE ] && rm $DHCP_OPTS_FILE
      [ -f $DHCP_OPT_INHER_FILE ] && {
        rm $DHCP_OPT_INHER_FILE
	dbg_log "remove dhcp inherite file and restart dnsmasq"
        /etc/init.d/dnsmasq restart
      }
    }

    [ -n "$iface" ] && {
      eval export CHANGED_network_$iface=1
    }
  }

  #load new interfaces based on UCI configuration
  load
 
  #restart dhcp server if needed
  [ -n "$APPLY_CHANGES" -a -z "$CHANGED_network_lan" ] || {
    dbg_log "restart dnsmasq"
    /etc/init.d/dnsmasq restart
  }

  #send signal to igmp process, that the interfaces have
  #been updated
  dbg_log "send signal to igmp"
  pid=`pidof igmp`
  kill -SIGHUP $pid

  # generate uci parameter changes
  dbg_log "generate uci parameters"
  [ ! -f /tmp/apply.old -a -s /etc/apply ] && /etc/apply

  # some services need be reloaded when source interface IP change
  reload_services

  dbg_log "Reload function completed"
  return 0
}

start() {
  wifi detect
  load
}

restart() {
  wifi detect
  reload
}

stop()
{
  wifi down
  ifdown lan
  ifdown wan
  ifdown loopback
}

