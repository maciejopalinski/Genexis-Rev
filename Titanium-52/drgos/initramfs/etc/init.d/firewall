#!/bin/sh /etc/rc.common

# Copyright (c) 2011 PacketFront International AB. All rights reserved.
#
# This Software and its content are protected by the Swedish Copyright Act
# (Sw: Upphovsr<E4>ttslagen) and, if applicable, the Swedish Patents Act
# (Sw: Patentlagen). All and any copying and distribution of the software
# and its content without authorization by PacketFront International AB is
# prohibited. The prohibition includes every form of reproduction and
# distribution.
#
# Author: pierre ingelfeldt
#

START=45
STOP=55

set_default_config() 
{
    uci setdefault /etc/config/firewall.icmp_echo=icmp_echo
}

start() {
    
    # TODO remove to kernel
    # TODO check that all getting loaded correctly
    insmod x_tables  2>&- >&-
    insmod ip_tables  2>&- >&-
    insmod ip6_tables  2>&- >&-
    insmod nfnetlink  2>&- >&-
    insmod nf_conntrack  2>&- >&-
    insmod nf_defrag_ipv4  2>&- >&-
    insmod nf_conntrack_ipv4  2>&- >&-
    insmod nf_nat  2>&- >&-
    insmod nf_conntrack_proto_gre  2>&- >&-
    insmod nf_conntrack_proto_sctp  2>&- >&-
    insmod nf_conntrack_netlink  2>&- >&-
    insmod xt_connbytes  2>&- >&-
    insmod xt_connmark  2>&- >&-
    insmod xt_conntrack  2>&- >&-
    insmod xt_helper  2>&- >&-
    insmod xt_state  2>&- >&-
    insmod xt_tcpudp  2>&- >&-
    insmod iptable_filter  2>&- >&-
    insmod iptable_nat  2>&- >&-
    insmod iptable_raw  2>&- >&-
    insmod ipt_MASQUERADE  2>&- >&-
    insmod ipt_REDIRECT  2>&- >&-
    insmod ipt_REJECT  2>&- >&-
    insmod xt_multiport  2>&- >&-
    insmod xt_tcpmss  2>&- >&-
    insmod xt_limit  2>&- >&-
    insmod xt_recent  2>&- >&-
    insmod ipt_ULOG  2>&- >&-
    insmod nf_conntrack_ftp  2>&- >&-
    insmod nf_nat_ftp  2>&- >&-
    insmod nf_conntrack_rtsp  2>&- >&-
    insmod nf_nat_rtsp  2>&- >&-
    insmod nf_conntrack_tftp  2>&- >&-
    insmod nf_nat_tftp  2>&- >&-
    insmod xt_string  2>&- >&-
    insmod ipt_time  2>&- >&-
   
    # Flush and zero all existing chains
    iptables -F
    iptables -Z

    # LOGDROP - used for logging packet drops. The rate of logging is itself
    #           limited to prevent this being the bottleneck or filling up
    #           logs too quickly. This is achieved by using the *recent* module...
    iptables -N LOGDROP
    iptables -A LOGDROP -m recent --rcheck --seconds 60 -j DROP
    iptables -A LOGDROP -m recent --set -j ULOG --ulog-prefix "Firewall: " --ulog-qthreshold 5
    iptables -A LOGDROP -j DROP		# Catchall

    # RATELIMIT - used for rate limiting connection attempts. Only accept 10
    #		connection attempts from the same source IP in 60s. Any more
    #		than this are dropped
    iptables -N RATELIMIT
    iptables -F RATELIMIT
    iptables -A RATELIMIT -m state --state NEW -m recent --name RATELIMIT --rcheck --seconds 60 --hitcount 10 -j LOGDROP
    iptables -A RATELIMIT -m state --state NEW -m recent --name RATELIMIT --set -j ACCEPT

    # SYNFLOOD - used to rate limit SYN attempts. First limits the number of
    # connection attempts from a single source IP, then further limits the
    # number of connections to 25/s - this does not crash the CMM
    # TODO? Might be better to use hashlimit instead of simple limit?
    iptables -N SYNFLOOD
    iptables -A SYNFLOOD -p tcp --syn -m recent --rcheck --seconds 1 --hitcount 3 --name SYNFLOOD -j LOGDROP
    iptables -A SYNFLOOD -p tcp --syn -m recent --set --name SYNFLOOD
    iptables -A SYNFLOOD -p tcp --syn -m limit --limit 25/s --limit-burst 50 -j RETURN
    iptables -A SYNFLOOD -j LOGDROP


    ### INPUT###
    #set the policy
    iptables -P INPUT ACCEPT

    # Allow self communication
    iptables -A INPUT -i lo -j ACCEPT

    #create three input chains for the firewall:
    # 1. input_rules chain: will do basic error checking.
    # 2. input_shaper chain: do shaping in here
    # 3. input_acl chain: any applied ACL is added into this chain

    #create default input rule chain and acl chain
    iptables -N .input_acl
    iptables -N .input_rules
    iptables -N .input_shaper
    iptables -N .input_wan_default
    iptables -N .input_lan_default


    #jump to input_shaper chain from INPUT chain
    iptables -A INPUT -j .input_shaper

    # ICMP rate limiting - limit to 10pps
#    iptables -A .input_shaper -p icmp -m limit --limit 10/s --limit-burst 1 -j .input_rules
#    iptables -A .input_shaper -p icmp -j LOGDROP
    # SYN rate limit
    iptables -A .input_shaper -p tcp --syn -j SYNFLOOD

    #...
    #...
    #Fallback
    iptables -A .input_shaper -j .input_rules
    
    #add rules into input_rules chain!
    iptables -A .input_rules -m state --state INVALID -j LOGDROP
    #Warning! This rule will not jump to input acl's which means that 
    #this traffic can't be blocked by a acl
    iptables -A .input_rules -m state --state RELATED,ESTABLISHED -j ACCEPT
    
    # Jump to input_acl chain from input_shaper chain - this is where operator-
    # defined chains are hooked into input chain
    iptables -A .input_rules -j .input_acl
    
    # Fallback rules if no ACLs are defined - these are called if operator-
    # defined ACLs either aren't present, e.g. as is case in default config,
    # or operator ACL falls through (which won't actually happen since there is
    # always a DROP at end of operator ACL rule chains
    config_load network
    config_get wiface wan ifname
    config_get liface lan ifname
    iptables -A .input_rules -i $wiface+ -j .input_wan_default		# All WAN interfaces, i.e. wan and vlanX
    iptables -A .input_rules -i $liface -j .input_lan_default		# LAN originated traffic
    iptables -A .input_rules -j ACCEPT
    
    
    # Default WAN acl chain that the input_acl chain will execute
    # after any user defined ACL has been applied - in this chain, rate limit
    # access to SSH and VoIP applications
    iptables -A .input_wan_default -p tcp --dport 22 -j RATELIMIT         # SSH
    iptables -A .input_wan_default -p tcp --dport 5060:5061 -j RATELIMIT  # VoIP: SIP
    iptables -A .input_wan_default -p tcp --dport 8082 -j RATELIMIT       # CWMP: TR069 ConnectionRequest port
    iptables -A .input_wan_default -p udp --dport 5060:5061 -j ACCEPT     # VoIP: SIP
    iptables -A .input_wan_default -p udp --dport 68 -j ACCEPT            # BOOTP/DHCP
    iptables -A .input_wan_default -p udp --dport 161 -j ACCEPT           # SNMP Agent
    iptables -A .input_wan_default -p udp --dport 1024:65535 -j ACCEPT    # VoIP: RTP
    iptables -A .input_wan_default -p udp --dport 9115 -j ACCEPT          # GAPS: Genexis GAPS
    iptables -A .input_wan_default -p icmp -j ACCEPT                      # ICMP
    iptables -A .input_wan_default -j LOGDROP

    # Default LAN acl chain that the input_acl chain will execute
    # after any user defined ACL has been applied
    iptables -A .input_lan_default -p tcp --dport 80 -j ACCEPT            # WWW/HTTP
    iptables -A .input_lan_default -p tcp --dport 5000 -j ACCEPT          # Universal Plug and Play
    iptables -A .input_lan_default -p udp --dport 67 -j ACCEPT            # BOOTP & DHCP
    iptables -A .input_lan_default -p udp --dport 53 -j ACCEPT            # DNS 
    iptables -A .input_lan_default -p udp --dport 1900 -j ACCEPT          # STUN Priority 1 port
    iptables -A .input_lan_default -p icmp -j ACCEPT                      # ICMP
    iptables -A .input_lan_default -j LOGDROP


   ### OUTPUT###
    #set the policy
    iptables -P OUTPUT ACCEPT

    # Allow self communication
    iptables -A OUTPUT -o lo -j ACCEPT

    #create two output chains for the firewall:
    # 1. output_rules chain: will do basic error checking.
    # 2. output_acl chain: any applied ACL is added into this chain

    #create default output rule chain and acl chain
    iptables -N .output_rules
    iptables -N .output_icmp
    iptables -N .output_acl

    #jump to output_rules chain from OUTPUT chain
    iptables -A OUTPUT -j .output_icmp


    #jump to output_shaper chain from output_rules chain
    iptables -A .output_icmp -j .output_rules

    #add rules into output_rules chain!
    iptables -A .output_rules -m state --state INVALID -j LOGDROP
    #Warning! This rule will not jump to output acl's which means that 
    #this traffic can't be blocked by a acl
    iptables -A .output_rules -m state --state RELATED,ESTABLISHED -j ACCEPT

    # ICMP rate limiting - limit to 10pps
    #...
    #...
    
    #jump to output_icmp chain from output_rules chain
    iptables -A .output_rules -j .output_acl

    ## FORWARD
    # Set the default policy
    iptables -P FORWARD DROP

    # Create a chain for filtering forwarding traffic
    # Be careful, dont name anything *forwarding*! The configure_nat script 
    # will remove anything named that!!
    iptables        -N forward_filter_rules

    # Add rule chains to FORWARD chain
    iptables        -A FORWARD -j forward_filter_rules
    iptables	    -A FORWARD -j LOGDROP	# Everything from here is dropped so must be last rule in chain


    #it's OK to allow multicasts in the firewall. The multicasts will be blocked by the kernel if not
    #a forwarding rule has been set by igmp proxy.
    . /etc/functions.sh
    config_load network
    config_get LAN lan ifname     
    iptables -A forward_filter_rules ! -i $LAN -d 224.0.0.0/4 -m state --state NEW -j ACCEPT
    # Allow established packets
    iptables -A forward_filter_rules -m state --state RELATED,ESTABLISHED -j ACCEPT

}

reload() {    
    #NOTE! This should be removed when icmp for ACL is supported
    # Enable/disable ICMP echo replies - note we do it this way (rather than
    # disabling in the kernel, since it gives ability to define on a per
    # interface basis          
                         
    #jump to output_shaper chain from output_rules chain
    iptables -I .output_icmp -j .output_rules
    while [ $? -eq 0 ]; do
	iptables -D .output_icmp 2
    done		
    interfaces=`uci get firewall.icmp_echo.interface 2>/dev/null`
    [ -n "$interfaces" ] && {
        for interface in $interfaces ; do
            local ifname=`uci -P /var/state get network.${interface}.ifname`
	    [ -n "$ifname" ] && {
                iptables -I .output_icmp -p icmp --icmp-type 0 --out-interface $ifname -j LOGDROP
            }
        done
    }
}
restart() {
    reload
}

stop() {

    # Flush and zero all existing chains
    iptables -F
    iptables -Z

    true
}
