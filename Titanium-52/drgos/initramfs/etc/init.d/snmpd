#!/bin/sh /etc/rc.common
# Copyright (C) 2008 OpenWrt.org
START=90

DEFAULT=/etc/default/snmpd
LIB_D=/var/lib/snmp
LOG_D=/var/log
RUN_D=/var/run
PID_F=$RUN_D/snmpd.pid
RUN_C=$RUN_D/snmpd.conf

LINK_UPDOWN_TRAP=no

agentaddress="UDP:161"

debug_snmpd=0
snmpd_log_file=/tmp/snmpd.log

[ -f /tmp/debug_snmpd ] && {
  debug_snmpd=1
  local msg="snmpd[$0 $@] started at $(date)"

  logger -s -t snmpd -p daemon.debug "$msg"
  echo "$msg" >> $snmpd_log_file
}

dbg_log() {
  [ $debug_snmpd = 1 ] && { 
    local date=`date +%s`
    local msg="$@"
    msg="${date}: ${msg}"
    logger -s -t snmpd -p daemon.debug "${msg}"
    echo "$msg" >> $snmpd_log_file
  }
}


snmpd_notify_add() {
	local cfg="$1"
	local host community version type

    # trap source interface ipaddress to net-snmp in 'clientaddr'
    local client_addr=
    local proto="none"
    local src_intf_snmp=$(uci -q get snmpd.@agent[0].agentinterface)      
    [ -z "$src_intf_snmp" ] && src_intf_snmp=$(uci -q get network.default.wan_if)
    [ -n "$src_intf_snmp" ] && proto=$(/sbin/uci -q get network.$src_intf_snmp.proto)
    case "$proto" in
       static)
          client_addr=$(/sbin/uci get network.$src_intf_snmp.ipaddr)
          ;;
       dhcp)
          client_addr=$(/sbin/uci -P /var/state get network.$src_intf_snmp.ipaddr)
          ;;
       pppoe)
          client_addr=$(/sbin/uci -P /var/state get network.$src_intf_snmp.ipaddr)
          ;;
       none)
          ;;
       *)
          ;;
    esac
    if [ -n "$client_addr" ]; then
     # snmp traps will send sent using this IP address
     echo "clientaddr $client_addr" >> $RUN_C
    else
     # specified interface has no IP yet, we need to NOT send SNMP traps yet
     # we need to use an ipv4 address that can not be binded to, 127.0.0.2 should suffice
     echo "clientaddr 127.0.0.2" >> $RUN_C
    fi

	config_get host "$cfg" host
	[ -n "$host" ] || return 0
	config_get version "$cfg" version
	[ -n "$version" ] || return 0
	config_get type "$cfg" type
	[ -n "$type" ] || return 0
	config_get community "$cfg" community
	[ -n "$community" ] || return 0
	if [ "$version" == "1" ]
	then
	echo "trapsink $host $community" >> $RUN_C
	fi
	if [ "$version" == "2" ]
	then
	   if [ "$type" == "inform" ]
	   then
	   echo "informsink $host $community" >> $RUN_C
	   else
	   echo "trap2sink $host $community" >> $RUN_C
	   fi
	fi 
	if [ "$version" == "3" ]
	then
	# this format does not agree with web man pages, needs to be revisted
	echo "trapsess -v $version -c $community $host" >> $RUN_C
	fi
	# enable link up/down trap, just add these parameters once
	if [ "$LINK_UPDOWN_TRAP" == "no" ]; then
		echo "rouser userro" >> $RUN_C
		echo "iquerySecName userro" >> $RUN_C
		echo "agentSecName userro" >> $RUN_C
		echo "linkUpDownNotifications yes" >> $RUN_C
		# set the flag
		LINK_UPDOWN_TRAP=yes
	fi
}
snmpd_agent_add() {
	local cfg="$1"
        local notifyauthfail
	[ -n "$agentaddress" ] || return 0
	echo "agentaddress $agentaddress" >> $RUN_C
	dbg_log "agentaddress $agentaddress"
	config_get notifyauthfail "$cfg" notifyauthfail
	[ -n "$notifyauthfail" ] || return 0
	echo "authtrapenable $notifyauthfail" >> $RUN_C
}
snmpd_system_add() {
	local cfg="$1"
	local syslocation syscontact sysname sysservice sysdescr sysobjectid
	config_get syslocation "$cfg" sysLocation
	[ -n "$syslocation" ] && echo "sysLocation $syslocation" >> $RUN_C
	config_get syscontact "$cfg" sysContact
	[ -n "$syscontact" ] && echo "sysContact $syscontact" >> $RUN_C
	config_get sysname "$cfg" sysName
	[ -n "$sysname" ] && echo "sysName $sysname" >> $RUN_C
	config_get sysservice "$cfg" sysService
	[ -n "$sysservice" ] && echo "sysService $sysservice" >> $RUN_C
	config_get sysdescr "$cfg" sysDescr
	[ -n "$sysdescr" ] && echo "sysDescr $sysdescr" >> $RUN_C
	# sysObjectID is handle exclusively below, based on target model
	# config_get sysobjectid "$cfg" sysObjectID
	# [ -n "$sysobjectid" ] && echo "sysObjectID $sysobjectid" >> $RUN_C

	# Bug 20677, 21029: sysObjectID MUST be driven by target model
	local sysobjid=`uci get usp.product.prodname`
	if test "${sysobjid}" = "DRG701" ; then
        echo "sysObjectID 1.3.6.1.4.1.9303.1.3.9" >> $RUN_C
	elif test "${sysobjid}" = "DRG702" ; then
        echo "sysObjectID 1.3.6.1.4.1.9303.1.3.10" >> $RUN_C
	elif test "${sysobjid}" = "DRG703" ; then
        echo "sysObjectID 1.3.6.1.4.1.9303.1.3.11" >> $RUN_C
	elif test "${sysobjid}" = "DRG711" ; then
        echo "sysObjectID 1.3.6.1.4.1.9303.1.3.12" >> $RUN_C
	elif test "${sysobjid}" = "DRG712" ; then
        echo "sysObjectID 1.3.6.1.4.1.9303.1.3.13" >> $RUN_C
	elif test "${sysobjid}" = "DRG714" ; then
        echo "sysObjectID 1.3.6.1.4.1.9303.1.3.14" >> $RUN_C
	elif test "${sysobjid}" = "DRG716" ; then
        echo "sysObjectID 1.3.6.1.4.1.9303.1.3.15" >> $RUN_C
	elif test "${sysobjid}" = "DRG718" ; then
        echo "sysObjectID 1.3.6.1.4.1.9303.1.3.16" >> $RUN_C
	elif test "${sysobjid}" = "DRG719" ; then
        echo "sysObjectID 1.3.6.1.4.1.9303.1.3.17" >> $RUN_C
	# default to DRG716 when type is not known
	else
        echo "sysObjectID 1.3.6.1.4.1.9303.1.3.15" >> $RUN_C
	fi 
}
snmpd_com2sec_add() {
	local cfg="$1"
	local secname spource community com2sec
	config_get secname "$cfg" secname
	[ -n "$secname" ] || return 0
	config_get source "$cfg" source
	[ -n "$source" ] || return 0
	config_get community "$cfg" community
	[ -n "$community" ] || return 0
	echo "com2sec $secname $source $community" >> $RUN_C
}
snmpd_group_add() {
	local cfg="$1"
	local group version secname
	config_get group "$cfg" group
	[ -n "$group" ] || return 0
	config_get version "$cfg" version
	[ -n "$version" ] || return 0
	config_get secname "$cfg" secname
	[ -n "$secname" ] || return 0
	echo "group $group $version $secname" >> $RUN_C
}
snmpd_view_add() {
	local cfg="$1"
	local viewname type oid mask
	config_get viewname "$cfg" viewname
	[ -n "$viewname" ] || return 0
	config_get type "$cfg" type
	[ -n "$type" ] || return 0
	config_get oid "$cfg" oid
	[ -n "$oid" ] || return 0
	# optional mask
	config_get mask "$cfg" mask
	echo "view $viewname $type $oid $mask" >> $RUN_C
}
snmpd_access_add() {
	local cfg="$1"
	local group context version level prefix read write notify
	config_get group "$cfg" group
	[ -n "$group" ] || return 0
	config_get context "$cfg" context
	[ -n "$context" ] || return 0
	[ "$context" == "none" ] && context='""'
	config_get version "$cfg" version
	[ -n "$version" ] || return 0
	config_get level "$cfg" level
	[ -n "$level" ] || return 0
	config_get prefix "$cfg" prefix
	[ -n "$prefix" ] || return 0
	config_get read "$cfg" read
	[ -n "$read" ] || return 0
	config_get write "$cfg" write
	[ -n "$write" ] || return 0
	config_get notify "$cfg" notify
	[ -n "$notify" ] || return 0
	echo "access $group $context $version $level $prefix $read $write $notify" >> $RUN_C
}
snmpd_pass_add() {
	local cfg="$1"
	local pass='pass'
	local miboid prog priority persist
	config_get miboid "$cfg" miboid
	[ -n "$miboid" ] || return 0
	config_get prog "$cfg" prog
	[ -n "$prog" ] || return 0
	config_get_bool persist "$cfg" persist 0
	[ $persist -ne 0 ] && pass='pass_persist'
	config_get priority "$cfg" priority
	priority=${priority:+-p $priority}
	echo "$pass $priority $miboid $prog" >> $RUN_C
}
snmpd_exec_add() {
	local cfg="$1"
        local execname prog args miboid
	config_get execname "$cfg" execname
	[ -n "$execname" ] || return 0
	config_get prog "$cfg" prog
	[ -n "$prog" ] || return 0
	config_get args "$cfg" args
	config_get miboid "$cfg" miboid
	echo "exec $miboid $execname $prog $args" >> $RUN_C
}
start() {
	[ -d $LIB_D ] || mkdir -p $LIB_D
	[ -d $LOG_D ] || mkdir -p $LOG_D
	[ -d $RUN_D ] || mkdir -p $RUN_D
	[ -f $RUN_C ] && rm -f $RUN_C

	config_load snmpd
	config_foreach snmpd_agent_add agent
	config_foreach snmpd_system_add system
	config_foreach snmpd_com2sec_add com2sec
	config_foreach snmpd_group_add group
	config_foreach snmpd_view_add view
	config_foreach snmpd_access_add access
	config_foreach snmpd_pass_add pass
	config_foreach snmpd_exec_add exec
	# traps get added last, so community and users exist
	config_foreach snmpd_notify_add notify
	
	[ -f $DEFAULT ] && . $DEFAULT
	$DEBUG /usr/sbin/snmpd $OPTIONS -f &

}
stop() {
    touch /var/term_snmp_pf_thread
    [ -f $PID_F ] && kill $(cat $PID_F)
    [ -f $RUN_C ] && rm -f $RUN_C
}
restart() {
    stop
    start
}

reload() {
    restart   
}


