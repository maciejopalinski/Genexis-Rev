#!/bin/sh /etc/rc.common
# Copyright (C) 2010 PacketFront System AB

START=85
STOP=01

RESOLV_CONF_HOST_VOIP_IF_HIS="/tmp/resolv.conf.sipappif.his"

system_config() {
  echo "not implemented yet"
}

set_default_config() {
  uci setdefault /etc/config/sip.global.debug_level=0
}

# sipapp args {-o : goes to stdout}, {-l <0-7> : syslog message level}
start() {
  local sipapp_pid=$(cat /var/run/sipapp.pid 2>/dev/null)
  local debug_level=`/sbin/uci get sip.global.debug_level`
  local cmd_args=""
  local src_intf_signal=$(uci -q get sip.global.signal_interface)

  [ -z "$src_intf_signal" ] && {
     src_intf_signal=$(uci -q get network.default.wan_if)
  }

  local src_intf_media=$(uci -q get sip.global.media_interface)
  [ -z "$src_intf_media" ] && {
     src_intf_media=$(uci -q get network.default.wan_if)
  }

  [ -f $RESOLV_CONF_HOST_VOIP_IF_HIS ] && {
  local sig_exist=$(cat $RESOLV_CONF_HOST_VOIP_IF_HIS | grep "SIGIF:$src_intf_signal")
  local med_exist=$(cat $RESOLV_CONF_HOST_VOIP_IF_HIS | grep "MEDIF:$src_intf_media")
  if [ ! -n "$sig_exist" ] || [ ! -n "$med_exist" ]; then
     #re-evaluate dnsmasq dynamic settings
     . /bin/dns_eval.sh
     dns_evaluate "sipapp"
  fi
  }
  echo "SIGIF:$src_intf_signal" > $RESOLV_CONF_HOST_VOIP_IF_HIS
  echo "MEDIF:$src_intf_media" >> $RESOLV_CONF_HOST_VOIP_IF_HIS


  # bug #21963 - kill monitor script
  killall sip_mon
  rm -f /tmp/vapi_term_restart
  # restart sip_mon - monitor script process
  /usr/bin/sip_mon&

  if [ -n "$sipapp_pid" ] && [ -d "/proc/$sipapp_pid" ]; then
    echo "sipapp is already running"
    return 1
  fi

  # export uci config a file
  uci -P /var/state export sip > /tmp/sip.uci

  if [ -n "$debug_level" ] && [ "$debug_level" != "0" ]; then
    cmd_args="-l 7"
  fi

  /usr/bin/sipapp $cmd_args&
}

stop() {
  local max_loop=0
  local sipapp_pid=$(cat /var/run/sipapp.pid 2>/dev/null)

  # kill back ground sipapp process automatic restarter script
  killall sip_mon
  rm -f /tmp/vapi_term_restart

  [ -z "$sipapp_pid" ] && return 0

  touch /tmp/term_sipapp
  sleep 1

  while [ -n "$sipapp_pid" -a -d "/proc/$sipapp_pid" ] ; do
    # wait for sippapp to respond
    sleep 1

    # increment the loop counter
    max_loop=`expr $max_loop + 1`
    echo "waiting sipapp terminate count=" $max_loop

    # if >= 4 seconds, then just do a kill to all sipapp processes
    if [ $max_loop -ge 4 ] ; then
      echo "sipapp normal term failed, doing kill"
      kill -9 $sipapp_pid
    fi

    # if >= 10 seconds, something is drastically wrong, abort out
    if [ $max_loop -ge 10 ] ; then
      echo "sipapp normal terminate failed, abort stop()"
      return 1;
    fi
  done

  # remove the pid file
  rm -f /var/run/sipapp.pid
}

restart() {
  stop
  start
}

reload() {
  restart
}

