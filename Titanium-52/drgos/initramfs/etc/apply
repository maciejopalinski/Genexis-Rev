#!/bin/sh

#
# Apply script
#
# This script should be run after any changes have made been to the 
# UCI parameters to apply them. The argument(s) is a list of modules
# that have had config changes since last apply.
#

mod_changed=$*
debug_apply=0
apply_log_file=/tmp/apply.log


[ -f /tmp/debug_apply ] && {
  debug_apply=1
  local msg="apply[$0 $@] started at $(date)"

  logger -s -t apply -p daemon.debug "$msg"
  echo "$msg" >> $apply_log_file
}

dbg_log() {
  [ $debug_apply = 1 ] && {
    local date=`date +%s`
    local msg="$@"
    msg="${date}: ${msg}"
    logger -s -t apply -p daemon.debug "$msg"
    echo "$msg" >> $apply_log_file
  }
}

err_log() {
    logger -s -t apply -p daemon.err "$@"
}

if echo $* | grep -q network && echo $* | grep -q wireless; then
    dbg_log "Skipping wireless module since network module is present"
    mod_changed=`echo $mod_changed | sed 's/wireless//g'`
fi

#Add dependencies, acl and nat needs to be started 
#after route and network script

# - Fix for #Bug #21648: Traffic are not NATed when WAN is set to static IP

# -Restart nat, which is required if NAT output
# interface has been defined (natexternaliface).
# nat script will update iptables rules.

# -Restart acl, which is required if acl's has changed
# on any interface.

if echo $* | grep -q '^network$'; then
    dbg_log "Add nat module after network module"
    if echo $* | grep -q nat; then
        mod_changed=`echo $mod_changed | sed 's/nat//g'`
    fi

    dbg_log "Add acl module after network module"
    if echo $* | grep -q acl; then
        mod_changed=`echo $mod_changed | sed 's/acl//g'`
    fi
    
    mod_changed="$mod_changed nat"
    mod_changed="$mod_changed acl"
elif echo $* | grep -q '^route$'; then
    dbg_log "Add nat module after route module"
    if echo $* | grep -q nat; then
        mod_changed=`echo $mod_changed | sed 's/nat//g'`
    fi
    mod_changed="$mod_changed nat"
fi

if echo $* | grep -q network6; then
    dbg_log "Add firewall6 module after network6 module"
    if echo $* | grep -q firewall6; then
        mod_changed=`echo $mod_changed | sed 's/firewall6//g'`
    fi
    mod_changed="$mod_changed firewall6"
fi

dbg_log "starting apply for modules: $mod_changed"

#
# Translate module 
# Some config modules need some other /etc/init.d script to be executed
#
mod_translate() {
  case "$1" in
    dhcp)  echo "dnsmasq" ;;
    upnpd) echo "miniupnpd" ;;
        *) echo "$1" ;;
  esac
}

#
# package, config, option, list - handle uci export data
#
package() {
    export PACK="$1"
    export CONFIG_NUM_SECTIONS=0
    export CONFIG_SECTIONS=""
    export "${PRE}_${PACK}_CONFIG_NUM_SECTIONS=0"
}

config () {
    local cfgtype="$1"
    local name="$2"

    export CONFIG_NUM_SECTIONS=$(($CONFIG_NUM_SECTIONS + 1))
    export "${PRE}_${PACK}_CONFIG_NUM_SECTIONS=$CONFIG_NUM_SECTIONS"
    name="${name:-cfg$CONFIG_NUM_SECTIONS}"
    export CONFIG_SECTION="$name"
    export CONFIG_SECTIONS="$CONFIG_SECTIONS $name"
    export "${PRE}_${PACK}_CONFIG_${CONFIG_SECTION}_TYPE=$cfgtype"
    export "${PRE}_${PACK}_CONFIG_SECTIONS=$CONFIG_SECTIONS"
}

option() {
    local varname="$1"; shift
    local value="$*"

    export "${PRE}_${PACK}_${CONFIG_SECTION}_${varname}=$value"
    [ -n "$CMP" ] && eval oldval="\$${CMP}_${PACK}_${CONFIG_SECTION}_${varname}"
    if [ -n "$CMP" -a "$oldval" != "$value" ]; then
      [ "$varname" = "uptime" -a "$PACK" = "network" ] || {
        dbg_log "${PACK}_${CONFIG_SECTION}_${varname} changed: '$oldval'!='$value'"
        export "CHANGED_${PACK}_${CONFIG_SECTION}_${varname}=1"
        export "CHANGED_${PACK}_${CONFIG_SECTION}=1"
        export "CHANGED_${PACK}=1"
      }
    fi
}

list() {
    option $*
}

#
# gen_changes - generate changes vars
#
gen_changes() {
  if [ -z "$2" ]; then
    PRE=NEW
    CMP=XXX
    source $1
  else
    PRE=OLD
    source $1
    PRE=NEW
    CMP=OLD
    source $2
    PRE=OLD
    CMP=NEW
    source $1
  fi
  export "APPLY_CHANGES=1"
}

# Notice that "-p /var/state" or "-P /var/state" MUST NOT be passed to uci
# when exporting the current configurations.
uci export > /tmp/apply.new

if [ -f /tmp/apply.old ]; then 
    gen_changes /tmp/apply.old /tmp/apply.new
fi
mv  /tmp/apply.new /tmp/apply.old

#
# Call reload for all modules that has changed config
#
res=0
for mod in $mod_changed; do
    mod=`mod_translate $mod`

    [ ! -x /etc/init.d/$mod ] && { 
      err_log "missing /etc/init.d/$mod"
      res=1
      continue
    }

    dbg_log "running /etc/init.d/$mod reload"
    /etc/init.d/$mod reload
    [ $? != 0 ] && { 
      dbg_log "failed, running /etc/init.d/$mod restart"
      /etc/init.d/$mod restart
      [ $? != 0 ] && {
        dbg_log "/etc/init.d/$mod restart failed"
        res=1
      }
    }
done

dbg_log "apply ended at $(date)"

exit $res
