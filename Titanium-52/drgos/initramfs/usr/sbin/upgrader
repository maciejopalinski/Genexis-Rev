#!/bin/ash

. /etc/functions.sh

usage_info() {
    echo >&2 \
    "Usage:
        $0 -h
        $0 -v
        $0 [-r new|old]] [-t firmware|bootloader|bootstrap] [-b] URL
        $0 [-r new|old]] [-t firmware|bootloader|bootstrap] [-b] FILE
        $0 -o [-c] FILE
        $0 -u IMAGE_NAME

     -r new|old    specify which of the two current software images
                   will be upgraded by the incoming software.
                   For bootloader, the newer copy is replaced by default;
                   while for firmware, the older one is replaced by
                   default

     -h            display this help and exit

     -t firmware | bootloader | bootstrap
                   specify the type of software to be upgraded.
                   The default type is "firmware" 

     -b            reboot after a successful firmware upgrade

     -c            force commit of the upgraded firmware (not applicable
                   to bootloader, or bootstrap)

     -o            use OMCI upgrade procedure
                   File should only be located in /tmp folder.
                   The filename may contain specific information to
                   indicate which copy of firmware to replace.

     -u            Create a .boot file if one does not exist already.
		   Parameter is name of firmware loaded and therefore to be
		   committed for next boot

     FILE          specify a local file as the source of firmware.

     IMAGE_NAME    specify the image name to boot

     URL           specify a URL as the source, which could be one of the
                   following
                         tftp://[HOST]/[FILENAME]
                   or
                         http://[HOST][:PORT]/[PATHFILENAME]"

}

parse_command_line() {
  while getopts bhu:t:i:r:co opt
  do
    #echo "$opt $OPTIND $OPTARG"
    case "$opt" in
      i)
        if test "$OPTARG" = "wan" ; then
          INTERFACE="$OPTARG"
        elif test "$OPTARG" = "lan" ; then
          INTERFACE="$OPTARG"
        else
          echo "Unsupported interface -- $OPTARG, using wan instead"
        fi
      ;;
      t)
        if test "$OPTARG" = "firmware" -o "$OPTARG" = "fw"; then
          IMG_TYPE="firmware"
        elif test "$OPTARG" = "bootloader" -o "$OPTARG" = "ldr"; then
          IMG_TYPE="bootloader"
        elif test "$OPTARG" = "bootstrap" -o "$OPTARG" = "st"; then
          IMG_TYPE="bootstrap"
        else
          logger -t "upgrader" -s "Unsupported type -- $OPTARG, exit..."
          exit 0
        fi
      ;;
      r)  
        if test "$OPTARG" = "old" ; then
          REPLACE_NEW_BOOTLOADER=0
        else
          REPLACE_NEW_BOOTLOADER=1
        fi
      ;;
      c)
        FORCE_COMMIT=1
      ;;
      o)
        OMCI_UPGRADE=1
      ;;
      b)
        DO_REBOOT=1
      ;;
      u)
	create_boot_config "$OPTARG"
	exit 0
      ;;
      h|*)   # unknown flag
        usage_info
      exit 0
      ;;
    esac
  done
}

get_gpon_state() {
  RETVAL=$FALSE

  if [ -f /drg/bin ]; then
	  cd /drg/bin
	  ./blsend.exe sessioninit $PPID >/dev/null 2>&1
	  if test "$?" = "0" ; then
	    GPON_STATE=`./blsend.exe send $PPID /application/ch/ggs |grep -i "Admin state" |awk -F: '{print $2}' |sed 's/^ *//;s/ *$//'`
	    # TODO: destroy $PPID session

	    if test "$GPON_STATE" = "Active" ; then
	      RETVAL=$TRUE
	    fi
	  fi
	  cd $PWD
  else
	  RETVAL=$TRUE
  fi

  return $RETVAL
}

link_is_up() {
  if test "$1" = "WAN" ; then
    # TODO: parse build flavor to determine the WAN interface(GPON or others?).
    get_gpon_state
    return $?
  elif test "$1" = "LAN" ; then
    echo "LAN"
  else
    echo "$1"
  fi
}

#TODO: do more checkings for the URL
is_valid_url() {
  return $TRUE
}

get_url_type() {
  echo "$1" |grep -q "^http"
  if test "$?" = "0" ; then
    URL_TYPE="http"
  else
    echo "$1" |grep -q "^tftp"
    if test "$?" = "0" ; then
      URL_TYPE="tftp"
    fi
  fi

}

download_image() {
  cd /tmp/
  if [ "$OMCI_UPGRADE" = "1" ]; then
    if test "$INTERFACE" != "wan" ; then
      logger -t "upgrader" -s "OMCI software download can only be performed through WAN interface"
      return 7
    fi
    # Image downloaded by OMCI stack, just move it to /tmp/
    mv -f $URL . 2>/dev/null
  elif test "$URL_TYPE" = "http" ; then
    rm -f $IMAGE_FILE
    logger -t "upgrader" -s "Downloading image ... "
    $WGET "$URL" >/dev/null 2>&1
    if test "$?" != "0" ; then
      logger -t "upgrader" -s "HTTP failed"
      return 5
    fi
    logger -t "upgrader" -s "Download completed"
  elif test "$URL_TYPE" = "tftp" ; then
    TFTP_SERVER=`echo $URL |cut -d'/' -f 3`
    TFTP_FILE=`echo $URL |cut -d'/' -f 4-`
    rm -f $IMAGE_FILE
    logger -t "upgrader" -s "Downloading image ... "
    $TFTP -g -l /tmp/$IMAGE_FILE -r $TFTP_FILE $TFTP_SERVER
    if test "$?" != "0" ; then
      logger -t "upgrader" -s "TFTP failed"
      return 6
    fi
    logger -t "upgrader" -s "Download completed"
  else
    # local file, just move it to /tmp if need
    if [ "$URL" != "/tmp/$IMAGE_FILE" ] && [ "$URL" != "$IMAGE_FILE" ] ; then
	rm -f $IMAGE_FILE
	mv -f $URL . 2>/dev/null
    fi
  fi

  return 0
}

# $1: Config filename
# $2: ME id
# $3: Version
# Called with fs_lock() still in force - be careful
update_boot_config() {
  local bCOMMITTED=$FALSE
  local AnotherImgID="00"

  logger -t "upgrader" -s "update_boot_config(): firmware $3, slot $2"
  if test "$2" = "00" ; then
    AnotherImgID="01"
  fi

  . /lib/boot/set_boot_param.sh

  if [ ! -f "$1" ] ; then
    logger -t "upgrader" -s "Boot config file does not exist, creating one..."
    touch $1
    fs_unlock

    # Create the parameters
    set_boot_param "img00=img00"
    set_boot_param "img01=img01"
    set_boot_param "global=boot"

    local AnotherImgName=`ls $JFFS2_MOUNT_DIR/$AnotherImgID/*.img 2>/dev/null | awk '{print $1}'`
    local VERSION=`chkimage $AnotherImgName 2>/dev/null| grep "^Image Name"|cut -d'-' -f 3-`
    if test "$AnotherImgName" != "" ; then
      set_boot_param "@img$AnotherImgID[0].version=$VERSION"
      set_boot_param "@img$AnotherImgID[0].is_valid=$TRUE"
      set_boot_param "@img$AnotherImgID[0].is_active=$FALSE"
    fi
  else
    fs_unlock
    $UCI get boot.@img00[0] >/dev/null 2>&1
    if test "$?" != "0" ; then
      # img00 section not exist, add it
      set_boot_param "img00=img00"
    fi
    $UCI get boot.@img01[0] >/dev/null 2>&1
    if test "$?" != "0" ; then
      # img01 section not exist, add it
      set_boot_param "img01=img01"
    fi
    $UCI get boot.global >/dev/null 2>&1
    if test "$?" != "0" ; then
      set_boot_param "global=boot"
    fi
  fi

  set_boot_param "global.last_written=$2"

  set_boot_param "@img$2[0].version=$3"
  if test "$OMCI_UPGRADE" = "0" -a "$FORCE_COMMIT" = "1" ; then
    bCOMMITTED=$TRUE
  fi
  set_boot_param "@img$2[0].is_active=$FALSE"
  set_boot_param "@img$2[0].is_committed=$bCOMMITTED"
  set_boot_param "@img$2[0].is_valid=$TRUE"
  if test "$bCOMMITTED" = "$TRUE" ; then
    # Only one firmware will be in committed status
    set_boot_param "@img$AnotherImgID[0].is_committed=$FALSE"
  else
    set_boot_param "@img$AnotherImgID[0].is_committed=$TRUE"
  fi
  fs_lock
}


# Parameters
# $1: image name
#
# Returns: 0 success
check_bootstrap_md5() {

  # Remove the footer - actual length isn't known, but it starts with
  # "DRGBOOT_FOOTER:".
  sed '/DRGBOOT_FOOTER:/,$d' < $1 > $1.tr	# Removes the footer except trailing <lf>
  size=`cat $1.tr | wc -c`
  let size=$size-1
  dd if=$1.tr of=$1.tr2 bs=1 count=$size >/dev/null 2>&1
  mv $1.tr2 $1.tr
  
  # Now have original raw image - calculate the MD5 checksum
  chk=`md5sum $1.tr | cut -d' ' -f1`

  # Extract the MD5 checksum contained in the bootstrap image
  size=`cat $1 | wc -c`
  let size=$size-32
  dd if=$1 of=$1.md5 bs=1 skip=$size count=32 >/dev/null 2>&1
  md5=`cat $1.md5`   

  rm $1.tr
  rm $1.md5

  if [ "$md5" == "$chk" ]; then
    return 0
  else
    return 1
  fi
}

upgrade_firmware_image() {
    [ -d $JFFS2_MOUNT_DIR ] || exit

    local upgrade_ok=1

    # Wait for filesystem to become read-only
    # (thus, no one else is using it).
    #until grep $JFFS2_MOUNT_DIR /proc/mounts | grep -q "jffs2.ro"; do
    #    sleep 2
    #done
    #sleep 1
    fs_lock
    if test "$?" != "0" ; then
      return $?
    fi

    IMAGE_SIZE=`du -k $IMAGE_FILE |awk '{print $1}'`
    IMAGES=`ls $JFFS2_MOUNT_DIR/00/*.img $JFFS2_MOUNT_DIR/01/*.img 2>/dev/null`
    IMAGE_COUNT=`ls -l $JFFS2_MOUNT_DIR/00/*.img $JFFS2_MOUNT_DIR/01/*.img 2>/dev/null |wc -l`
    if test "$OMCI_UPGRADE" = "0" ; then
      # Both slot are empty, pick 00
      if test "$IMAGE_COUNT" = "0" ; then
        IMG_ID="00"
        # Only 1 image in DRG, we should set it to boot anyway
        FORCE_COMMIT=1
      elif test "$IMAGE_COUNT" = "1" ; then
      # One slot is empty, pick that one
	if [ "${IMAGES#$JFFS2_MOUNT_DIR/01/}" != "${IMAGES}" ]; then
          IMG_ID="00"
        else
          IMG_ID="01"
        fi
      else
      # Both slots are occupied.
        IMG0_COMMITTED=`$UCI get boot.@img00[0].is_committed` 
        IMG1_COMMITTED=`$UCI get boot.@img01[0].is_committed`
        if [ `expr $IMG0_COMMITTED + $IMG1_COMMITTED` -ne "1" ]; then
        # Both or none is selected for boot, replace the oldest one
        # (this should never happen)
          LAST_WRITTEN=`$UCI get boot.global.last_written`
          if test -z "$LAST_WRITTEN" -o "$LAST_WRITTEN" = "01"; then
            IMG_ID="00"
          else 
            IMG_ID="01"
          fi
        else
        # One is selected for boot, replace the other one
          if test "$IMG0_COMMITTED" = "1"; then
            IMG_ID="01"
		  else
            IMG_ID="00"
          fi
        fi
      fi
    else
      CUR_IMG_ID=`basename $IMAGE_FILE | cut -d- -f 2 | cut -d. -f 1`
      if test "$CUR_IMG_ID" = "0" ; then
        IMG_ID="00"
      else
        IMG_ID="01"
      fi
    fi

    #mount -o remount,rw $JFFS2_MOUNT_DIR
    if [ ! -d $JFFS2_MOUNT_DIR/00 ] ; then
      mkdir $JFFS2_MOUNT_DIR/00
    fi

    if [ ! -d $JFFS2_MOUNT_DIR/01 ] ; then
      mkdir $JFFS2_MOUNT_DIR/01
    fi

    rm -f $JFFS2_MOUNT_DIR/$IMG_ID/*.img 2>/dev/null
    mv -f $IMAGE_FILE $JFFS2_MOUNT_DIR/$IMG_ID/$1.img 2>/dev/null

    if test "$?" = "0" ; then
       local v=`echo $1 |cut -d'-' -f 3-`

       VERSION=`chkimage $JFFS2_MOUNT_DIR/$IMG_ID/$1.img 2>/dev/null |grep "^Image Name"|cut -d'-' -f 3-`

       if [ -n "$VERSION" ] && [ "$VERSION" = "$v" ] ; then
          # upgrade system configuration for bootloader to load this image next time
          update_boot_config "$BOOT_CONFIG" $IMG_ID "$VERSION"
          upgrade_ok=0
       fi
    fi

    if [ "$upgrade_ok" = "1" ] ; then
      $LOG_ERROR "Upgrade failed: Firmware image check failure"
      rm -f $JFFS2_MOUNT_DIR/$IMG_ID/$1.img
    fi

    #mount -o remount,ro $JFFS2_MOUNT_DIR
    fs_unlock

    # To free pagecache, dentries and inodes
    echo 3 > /proc/sys/vm/drop_caches

    if [ "$upgrade_ok" == "0" -a "$DO_REBOOT" == "1" ]; then

        $LOG_ERROR "Firmware upgrade ok, will reboot in 5 seconds."

        sleep 5
        reboot
    fi

    return $upgrade_ok
}

# Create a boot config file - if no /config/.boot file exists, work out the
# most likely firmware, i.e. latest revision
#
# $1:	image name
create_boot_config() {
  local img_id
  local version

  logger -t "upgrader" -s "create_boot_config(): starting..."
  . /lib/boot/set_boot_param.sh

  fs_lock
  touch "$BOOT_CONFIG"
  # Unlock to allow link to be created
  fs_unlock

  set_boot_param "img00=img00"
  set_boot_param "img01=img01"
  set_boot_param "global=boot"

  # Read versions and states of files
  for dir in 00 01 ; do
    local full_image_name=`ls /config/$dir/*.img 2>/dev/null | awk '{print $1}'`
    local image_name=`ls /config/$dir/*.img 2>/dev/null | awk -F'/' '{print $4}'`
    local image_version=`chkimage $full_image_name 2>/dev/null| grep "^Image Name"|cut -d'-' -f 3-`

    if test "$image_version" != "" ; then
      set_boot_param "@img$dir[0].version=$image_version"
      set_boot_param "@img$dir[0].is_valid=1"
      set_boot_param "@img$dir[0].is_active=0"

      if [ "$image_name" == "$1" ] ; then
        set_boot_param "@img$dir[0].is_committed=1"
        set_boot_param "global.last_written=$dir"
        version=`$UCI get boot.@img"$dir"[0].version`
	img_id=$dir
      else
        set_boot_param "@img$dir[0].is_committed=0"
      fi
    else
      set_boot_param "@img$dir[0].version=''"
      set_boot_param "@img$dir[0].is_valid=0"
      set_boot_param "@img$dir[0].is_active=0"
      set_boot_param "@img$dir[0].is_committed=0"
    fi
  done

  logger -t "upgrader" -s "create_boot_config(): Selected image $version in slot $img_id"

  # Lock the filesystem and ensure the data is written to flash
  fs_lock
  sync
  fs_unlock
}

upgrade_bootloader() {
  B2=`cat /proc/mtd | grep -i $BOOTLOADER2_STRING | awk -F":" '{print $1}' | sed -e 's/\(mtd\)\([0-9]\)/\/dev\/\1block\2/g'`
  dd if=$B2 of=/tmp/b2.img bs=64 count=1 > /dev/null 2>&1

  local image_info=`chkimage /tmp/b2.img`
  if test "$?" = "0" ; then # Valid image header
    rm -f /tmp/b2.img
    B2_VER=`echo "$image_info" |grep "Image Name:" |sed "s/^.*[[:space:]]//g"| cut -d'-' -f 3`
  else
    rm -f /tmp/b2.img
    dd if=$IMAGE_FILE of=$B2 >/dev/null 2>&1
    return $?
  fi

  B1=`cat /proc/mtd | grep -i $BOOTLOADER1_STRING | awk -F":" '{print $1}' | sed -e 's/\(mtd\)\([0-9]\)/\/dev\/\1block\2/g'`
  dd if=$B1 of=/tmp/b1.img bs=64 count=1 > /dev/null 2>&1

  image_info=`chkimage /tmp/b1.img`
  if test "$?" = "0" ; then # Valid image header
    rm -f /tmp/b1.img
    B1_VER=`echo "$image_info" |grep "Image Name:" |sed "s/^.*[[:space:]]//g"| cut -d'-' -f 3`
  else
    rm -f /tmp/b1.img
    dd if=$IMAGE_FILE of=$B1 >/dev/null 2>&1
    return $?
  fi

  version_older_than $B1_VER $B2_VER
  if [ "$?" == "0" ] ; then
    if test "$REPLACE_NEW_BOOTLOADER" = "0" ; then
      BOOTLOADER="$B1"
    else
      BOOTLOADER="$B2"
    fi
  else
    if test "$REPLACE_NEW_BOOTLOADER" = "0" ; then
      BOOTLOADER="$B2"
    else
      BOOTLOADER="$B1"
    fi
  fi

  dd if=$IMAGE_FILE of=$BOOTLOADER >/dev/null 2>&1

  return $?
}

upgrade_bootstrap() {
  local upgrade_ok=0

  BLOCK=`cat /proc/mtd | grep -i $BOOTSTRAP_STRING | awk -F":" '{print $1}' | sed -e 's/\(mtd\)\([0-9]\)/\/dev\/\1block\2/g'`
  BS=`cat /proc/mtd | grep -i $BOOTSTRAP_STRING | awk -F":" '{print $1}' | sed -e 's/\(mtd\)\([0-9]\)/\/dev\/\1\2/g'`

  mtd unlock "$BS" >/dev/null 2>&1
  mtd erase  "$BS" >/dev/null 2>&1
  mtd write "$IMAGE_FILE" "$BS" >/dev/null 2>&1
  mtd lock "$BS" >/dev/null 2>&1

  # Verify that everything worked as expected, read the file back, and perform
  # MD5 checks on downloaded file against what is in flash now
  boot_size=`cat $IMAGE_FILE | wc -c`
  dd if="$BLOCK" of="_$IMAGE_FILE" bs=1 count=$boot_size >/dev/null 2>&1
  if [ `md5sum "$IMAGE_FILE" | cut -d' ' -f1` != `md5sum "_$IMAGE_FILE"  | cut -d' ' -f1` ]; then
    # Error, file not verified
    $LOG_ERROR "ERROR: Bootstrap file not verified correctly"
    upgrade_ok=1;
  fi

  rm _$IMAGE_FILE

  return $upgrade_ok
}

version_older_than() {
  local v1=0
  local v2=0

  for i in ${1//./ } ; do
    let "v1 = $v1*100 + $i"
  done

  for i in ${2//./ } ; do
    let "v2 = $v2*100 + $i"
  done

  if [ $v1 -lt $v2 ] ; then
    return 0
  else
    return 1
  fi
}

chk_bootstrap_file() {
  local image_info=`chkimage -b $IMAGE_FILE`

  if [ -z "$image_info" ] ; then
    $LOG_ERROR "Unknown image format: $IMG_TYPE image for $PROD_PLATFORM version $PROD_VER is expected."
    return 1
  fi

  local image_full_name=`echo "$image_info"|sed "s/[[:space:]].*$//g"`

  local image_name=`echo "$image_full_name" | cut -d'-' -f 1`
  if [ -z "$image_name" ] || [ "$image_name" != "$1" ]; then
     $LOG_ERROR "Error image type '$image_name': Image type '$1' is required."

     return 1
  fi

  local image_platform=`echo "$image_full_name" | cut -d'-' -f 2`
  if [ -z "$image_platform" ] || [ "$image_platform" != "$PROD_PLATFORM" ]; then
     $LOG_ERROR "Error platform '$image_platform': $IMG_TYPE image for platform '$PROD_PLATFORM' is required."

     return 1
  fi

  local image_ver=`echo "$image_full_name" | cut -d'-' -f 3`
  if [ -z "$image_ver" ] ; then
     $LOG_ERROR "No version found."

     return 1
  fi

  local min_version=`$UCI get drgos."$PROD_PLATFORM"_v"$PROD_VER"."$1"_min_version 2>/dev/null`
  if [ -n "$min_version" ]; then
     version_older_than $image_ver $min_version

     if [ "$?" == "0" ] ; then
        $LOG_ERROR "Error $IMG_TYPE version ($image_ver) : Minimal $1 version '$min_version' is required."

        return 1
     fi
  fi

  check_bootstrap_md5 $IMAGE_FILE
  if test "$?" != "0" ; then
     $LOG_ERROR "Error MD5 checksum in $IMAGE_FILE."

     return 1
  fi

  return 0
}

chk_image_file() {

  local image_info=`chkimage $IMAGE_FILE`

  if [ -z "$image_info" ] ; then
    $LOG_ERROR "Unknown image format: $IMG_TYPE image for $PROD_PLATFORM version $PROD_VER is expected."
    return 1
  fi

  local image_full_name=`echo "$image_info" |grep "Image Name:" |sed "s/^.*[[:space:]]//g"`
  local image_name=`echo "$image_full_name" | cut -d'-' -f 1`

  if [ -z "$image_name" ] || [ "$image_name" != "$1" ]; then
     $LOG_ERROR "Error image type '$image_name': Image type '$1' is required."

     return 1
  fi

  local image_platform=`echo "$image_full_name" | cut -d'-' -f 2`
  if [ -z "$image_platform" ] || [ "$image_platform" != "$PROD_PLATFORM" ]; then
     $LOG_ERROR "Error platform '$image_platform': $IMG_TYPE image for platform '$PROD_PLATFORM' is required."

     return 1
  fi

  local image_ver=`echo "$image_full_name" | cut -d'-' -f 3`
  if [ -z "$image_ver" ] ; then
     $LOG_ERROR "No version found."

     return 1
  fi

  local min_version=`$UCI get drgos."$PROD_PLATFORM"_v"$PROD_VER"."$1"_min_version 2>/dev/null`
  if [ -n "$min_version" ] ; then
     version_older_than $image_ver $min_version

     if [ "$?" == "0" ] ; then
        $LOG_ERROR "Error $IMG_TYPE version ($image_ver) : Minimal $1 version '$min_version' is required."

        return 1
     fi
  fi

  echo "$image_full_name"

  return 0
}

perform_upgrade() {
  cd /tmp

  case "$IMG_TYPE" in
    "firmware")
       local image_name=`chk_image_file "drgos"`

       if [ -z "$image_name" ] ; then
          $LOG_ERROR "Error $IMG_TYPE image: Upgrade is aborted."

          return 1;
       fi

       upgrade_firmware_image $image_name
       return $?
    ;;

    "bootloader")
       local image_name=`chk_image_file "drgldr"`

       if [ -z "$image_name" ] ; then
          $LOG_ERROR "Error $IMG_TYPE image: upgrade is aborted."

          return 1;
       fi

       upgrade_bootloader
       return $?
    ;;

    "bootstrap")
       chk_bootstrap_file "drgboot"
       if test "$?" != "0" ; then
          $LOG_ERROR "Error $IMG_TYPE image: upgrade is aborted."

          return 1;
       fi

       upgrade_bootstrap
       return $?
    ;;
  esac

  return 1;
}

signal_handler() {
  logger -t "upgrader" -s "Caught signal, exiting..."
  fs_unlock
  exit 0
}

TRUE=1
FALSE=0
REPLACE_NEW_BOOTLOADER=1
INTERFACE="wan"
URL=""
URL_TYPE="local"
OMCI_UPGRADE=0
FORCE_COMMIT=0
PWD=`pwd`
WGET=`which wget`
TFTP=`which tftp`
UCI="/sbin/uci"
JFFS2_MOUNT_DIR=/config
BOOT_CONFIG=/config/.boot
# Bootloader1 and bootloader2
B1=""
B2=""
IMG_ID=""
IMG_TYPE="firmware" # firmware, bootloader, or others
IMG0_COMMITTED=""
IMG1_COMMITTED=""
LAST_WRITTEN=""
PROD_PLATFORM=`$UCI get usp.product.platform | tr "[:upper:]" "[:lower:]"`
PROD_VER=`$UCI get usp.product.version | tr "." "_"`
JFFS2_STRING="jffs2"
BOOTLOADER1_STRING="bootloader1"
BOOTLOADER2_STRING="bootloader2"
BOOTSTRAP_STRING="bootstrap"
DO_REBOOT=0

LOG_ERROR="logger -p daemon.err -t upgrader -s"

# main()

OTHER_UPGRADER=`pidof -o %PPID upgrader`
if test "$OTHER_UPGRADER" != "" ; then
  logger -t "upgrader" -s "Another upgrader process is running, exit..."
  exit 1
fi

trap 'signal_handler' 1 2 3 15

parse_command_line $*

#if test "$UID" != "0" ; then
#  logger -t "upgrader" -s "Permission denied. Only root can perform this operation"
#  exit 1
#fi

shift `expr $OPTIND - 1`
if test "$#" = "0" ; then
  usage_info
  exit 0
elif test "$#" != "1" ; then
  logger -t "upgrader" -s "URL cannot contain space!"
  exit 2
fi

URL="$1"

link_is_up "WAN"
WAN_IS_ACTIVE=$?

if test "$INTERFACE" != "wan" ; then
  if test "$WAN_IS_ACTIVE" = "$TRUE" ; then
    logger -t "upgrader" -s "Upgrade via LAN is not allowed when WAN is up"
    exit 3
  fi
fi

is_valid_url "$URL"
IMAGE_FILE=`basename "$URL"`

get_url_type "$URL"

RETVAL=0

download_image
RETVAL=$?

if test "$RETVAL" = 0 ; then
  logger -t "upgrader" -s "Performing upgrade ... "
  perform_upgrade
  RETVAL=$?
fi

if test "$RETVAL" = 0 ; then
  logger -t "upgrader" -s "Upgrade $IMAGE_FILE finished"
else
  logger -t "upgrader" -s "Upgrade $IMAGE_FILE failed"
fi

rm -f $IMAGE_FILE

cd $PWD
exit $RETVAL
