#!/bin/sh
#
# This script is invoked by udhcpc when IP settings needs be changed.
#

debug_dhcp_client=0
dhcp_client_log_file=/tmp/dhcp_client.log
RESOLV_CONF_DHCPC_TMP="/tmp/resolv.conf.auto.dyn.dhcpc.$interface"
RESOLV_CONF_DHCPC_TMP_HIS="/tmp/resolv.dyn.dhcpc.his.$interface"
VENDOR_INFO_HISTORY="/tmp/gaps-vendor-info-his"
VENDOR_INFO_CURRENT="/tmp/gaps-vendor-info-cur"

[ -f /tmp/debug_dhcp_client ] && {
  debug_dhcp_client=1
  local msg="default.script[$0 $@] started at $(date)"

  logger -s -t udhcpc -p daemon.debug "$msg"
  echo "$msg" >> $dhcp_client_log_file
}

dbg_log() {
  [ $debug_dhcp_client = 1 ] && {
    local msg="$@"

    logger -s -t udhcpc -p daemon.debug "$msg"
    echo "$msg" >> $dhcp_client_log_file
  }
}

err_log() {
  logger -s -t udhcpc -p daemon.err "$@"
  [ $debug_dhcp_client = 1 ] && {
    echo "$@" >> $dhcp_client_log_file
  }
}

[ -z "$1" ] && err_log "Error: should be run by udhcpc" && exit 1

. /etc/functions.sh
include /lib/network

DHCP_SV="dnsmasq"
DHCP_OPTS_FILE="/tmp/dhcp_opts_file"
DHCP_OPT_INHER_FILE="/tmp/dhcp_opt_inher_file"
DHCPC_ROUTE_DEFAULT_FILE="/tmp/dhcpc-route-default-$interface"
DHCPC_ROUTE_HISTORY_FILE="/tmp/dhcpc-route-history-$interface"
DHCPC_ROUTE_TEMP_FILE="/tmp/dhcpc-route-temp-$interface"
DHCPC_ROUTE_ADD_FILE="/tmp/dhcpc-route-add-$interface"
DHCPC_ROUTE_DEL_FILE="/tmp/dhcpc-route-del-$interface"

#------------------------------------------------------------------------
# purpose: handle dhcp new lease, do not remove old gws if it is still in the new list and has same metric, else remove old gw(s)
# issue: ? route del can fail when interface is down, and when interface comes back up, then routes are still existing?
dhcpc_remove_default_gw_no_route_fixup() {
  # remove old default gw routes using file cached gw, dev and met
  local interface="$1"
  local this_set_gws="$2"
  local this_met="$3"

  [ -f $DHCPC_ROUTE_DEFAULT_FILE ] && {
    while read line; do
      # $line format: "gw $nh_gw dev $interface metric $met"
      met=${line##* }  # get last word
      nhgw=${line#* }  # remove first word
      nhgw=${nhgw%% *} # keep just first word
      del_rt=1

      for i in $this_set_gws ; do
        if [ "$i" == "$nhgw" ] && [ "$met" == "$this_met" ] ; then
          del_rt=0 # if same gw, interface and met, do not delete
        fi
      done

      [ $del_rt -ne 0 ] && {
        dbg_log "route del -net 0.0.0.0 $line"
        ret=`route del -net 0.0.0.0 $line`
      }

    done <$DHCPC_ROUTE_DEFAULT_FILE
    rm -f $DHCPC_ROUTE_DEFAULT_FILE
  }
}

dhcpc_add_new_routes() {
    local new_rt="-net $1 gw $2 dev $3 metric $4"
    echo $new_rt >> $DHCPC_ROUTE_TEMP_FILE

    [ -f $DHCPC_ROUTE_HISTORY_FILE ] && {
        while read line; do
            if [ "$new_rt" == "$line" ]; then
                return 0
            fi
        done <$DHCPC_ROUTE_HISTORY_FILE

        echo $new_rt >> $DHCPC_ROUTE_ADD_FILE
    }

    [ -f $DHCPC_ROUTE_HISTORY_FILE ] || {
        echo $new_rt >> $DHCPC_ROUTE_ADD_FILE
    }
}

dhcpc_del_old_routes() {
    [ -f $DHCPC_ROUTE_TEMP_FILE ] && {
        [ -f $DHCPC_ROUTE_HISTORY_FILE ] && {
            while read line_his; do
                local del_need=1

                while read line_tmp; do
                    if [ "$line_his" == "$line_tmp" ]; then
                        del_need=0
                        break 1
                    fi
                done <$DHCPC_ROUTE_TEMP_FILE

                [ $del_need -eq 1 ] && {
                    echo $line_his >> $DHCPC_ROUTE_DEL_FILE
                }

            done <$DHCPC_ROUTE_HISTORY_FILE
        }
    }
} 

dhcpc_reload_routes() {
    # $line format: "-net $net_id gw $nh_gw dev $interface metric $met"
    while read line; do
        ret=`route del $line`
    done <$DHCPC_ROUTE_DEL_FILE

    # $line format: "-net $net_id gw $nh_gw dev $interface metric $met"
    while read line; do
        ret=`route add $line`
    done <$DHCPC_ROUTE_ADD_FILE
}

open_dhcp_opt_file() {
  echo > $DHCP_OPTS_FILE
}

close_dhcp_opt_file() {
  local old
  local new

  [ ! -f $DHCP_OPT_INHER_FILE ] && {
    cat "$DHCP_OPTS_FILE" > "$DHCP_OPT_INHER_FILE"
    /etc/init.d/dnsmasq restart
    return 0
  }

  old=`cat "$DHCP_OPT_INHER_FILE"`
  new=`cat "$DHCP_OPTS_FILE"`
  if [ "$old" != "$new" ] ; then
    cat "$DHCP_OPTS_FILE" > "$DHCP_OPT_INHER_FILE"
    /etc/init.d/dnsmasq restart
  fi

# kill -SIGHUP `pidof $DHCP_SV`
}

add_dhcp_opt_str() {
  echo "dhcp-option-force=lan,$1,\"$2\"" >> $DHCP_OPTS_FILE
}

# Replace space delimited list, with comma delimited list
add_dhcp_opt_ip() {
  list=${2// /,}
  echo "dhcp-option-force=lan,$1,$list" >> $DHCP_OPTS_FILE
}

add_dhcp_opt() {
  # Can precede with "lan" or networkid. But need some way to know what
  # this should be
  echo "dhcp-option-force=lan,$1,$2" >> $DHCP_OPTS_FILE
}

hotplug_event() {
  scan_interfaces
  for ifc in $interfaces; do
    config_get ifname $ifc ifname
    [ "$ifname" = "$interface" ] || continue

    config_get proto $ifc proto
    [ "$proto" = "dhcp" ] || continue
    [ ifup = "$1" ] && {
      uci_set_state network "$ifc" ipaddr "$ip"
      uci_set_state network "$ifc" netmask "${subnet:-255.255.255.0}"
      uci_set_state network "$ifc" dnsdomain "$domain"
      uci_set_state network "$ifc" dns "$dns"
      uci_set_state network "$ifc" gateway "$router"
    }
    env -i ACTION="$1" INTERFACE="$ifc" DEVICE="$ifname" PROTO=dhcp STATE="$3" /sbin/hotplug-call iface "$2"
  done
}


to_url() {
    if [ "$1" = "/" ]; then
        [ -z "$2" ] || echo "tftp://$2/"
    else
        case $1 in
            tftp://*) echo "$1" ;;
            http://*) echo "$1" ;;
            *) [ -z "$2" ] || echo "tftp://$2/$1" ;;
        esac
    fi
}


firmware_upgrade() {
  url=$1
  # Two conditions must be met for downloading.
  # 1) There is no running upgrading instance.
  # 2) The firmware to be downloaded must be different from
  #    the one running currently
  upgrader_is_running=$(ps | grep upgrader | grep -v grep)
  if [ -n "$upgrader_is_running" ] ; then
    logger -t udhcpc "Firmware upgrade in progress - ignoring new request"
  else
    running_firmware=$(uname -r)
    # convert to filename (remove linux version
    # and add .img)
    running_image="${running_firmware#*-}.img"
    bootfile="${url##*/}"
    if [ "$bootfile" != "$running_image" ] ; then
      # Run the upgrader application in the background in
      # order to avoid blocking the running of dhcp client
      /usr/sbin/upgrader -c -b "$url" &
    else
      logger -t udhcpc "Repeat firmware upgrade request - ignored"
    fi
  fi
}



config_download() {
  url=$1
  cnfgfile="${url##*/}"

  [ -z "$cnfgfile" ] && {
    config_get macA "eth" ethaddr
    macA=`echo $macA | sed 's/://g'`

    url="$url$macA.cfg"
  }

  # Two conditions must be met for downloading.
  # 1) There is no running config_dl instance.
  # 2) If the sname/filename is the same as a previous config download
  #    it will be considered unchanged and not downloaded again
  config_dl_is_running=$(ps | grep '[c]onfig_dl')
  if [ -n "$config_dl_is_running" ] ; then
    logger -t udhcpc "Configuration download in progress - ignoring new request"
  else
    prev_config_dl=`cat /tmp/prev_config_dl 2> /dev/null`
    if [ "$prev_config_dl" != "$url" ] ; then
      # Run the config download in the background in order to
      # avoid blocking the running of dhcp client
      /usr/sbin/config_dl "$url" &
    else
      logger -t udhcpc "Repeat configuration download request - ignored"
    fi
  fi
}



tr069_url() {
  # BusyBox has been patched to convert the binary format described
  # in RFC2132 section 8.4 to a corresponding ASCII format, for
  # easy parsing in shell scripts. The encapsulated vendor-specific
  # headers gets converted to a six character, zero padded integer
  # string. Example: 002005ABCDE where ID=2, length=5 and data=ABCDE.
  # The integers are of base 10.
  local DYNAMIC_USER
  local DYNAMIC_PASS
  local DYNAMIC_URL
  local ENV_LEN=0
  local ACCU_LEN=0
  local ID=0
  local LEN=0
  local ERR=0
  local URL_TYPE=0
  local URL_LEN=0
  local URL_FULL=""
  local URL_FOUND=0

  [ -z "$vendorinfo" ] && return
  ENV_LEN=`echo -n $vendorinfo | wc -c`
  DYNAMIC_USER=""
  DYNAMIC_PASS=""
  DYNAMIC_URL=""
  T=""

  # Check all encapsulated vendor-specific extensions. Has
  # we got one which looks like an ACS URL?
  while [ $ID -ge 0 -a $LEN -ge 0 -a $ACCU_LEN -lt $ENV_LEN -a $ERR -eq 0 ]; do
    URL_TYPE=0
    URL_LEN=0
    URL_FULL=""
    URL_FOUND=0

    ID=`echo -n $vendorinfo | dd bs=1 count=3 skip=${ACCU_LEN} 2>/dev/null`
    if [ $ID -ge 0 -a $ID -le 255 ] 2>/dev/null; then

      LEN=`echo -n $vendorinfo | dd bs=1 count=3 skip=$((ACCU_LEN+3)) 2>/dev/null`
      if [ $LEN -ge 0 -a $LEN -le 255 ] 2>/dev/null; then

        DATA=`echo -n $vendorinfo | dd bs=1 count=${LEN} skip=$((ACCU_LEN+6)) 2>/dev/null`
        echo "$DATA" | grep -q "^http://" && URL_FOUND=1
        #echo "Suboption ID=$ID lenght=$LEN data=$DATA"

        if [ $ID -eq 1 -a $URL_FOUND -eq 1 ]; then
          # Bingo, got an encapsulated option which looks like ACS URL
          URL_TYPE=$ID
          URL_LEN=$LEN
          URL_FULL="$DATA"
          break
        fi
      else
        ERR=1
        break
      fi
    else
      ERR=1
      break
    fi

    ACCU_LEN=`expr $ACCU_LEN + 6 + $LEN`
  done


  if [ $URL_FOUND -ne 1 -o $ERR -ne 0 ]; then
    echo "Bad TR-069 URL, ignoring it."
    logger -t udhcpc "Bad TR-069 URL, ignoring it."
    return
  fi

  # Does the ACS URL contain username and password too?
  if echo "$URL_FULL" | grep -q "^http.*@"; then
    DYNAMIC_USER=$(echo "${URL_FULL##http://}" | cut -d @ -f 1 | cut -d : -f 1)

    # Does the URL contain password too?
    if echo "${URL_FULL##http://}" | cut -d @ -f 1 | grep -q ":"; then
      DYNAMIC_PASS=$(echo "${URL_FULL##http://}" | cut -d @ -f 1 | cut -d : -f 2)
    fi

    # Extract the URL, deleting the username and password
    T=$(echo "${URL_FULL##http://}" | cut -d @ -f 2)
    [ -n "$T" ] && DYNAMIC_URL="http://$T"
  else
    DYNAMIC_URL="$URL_FULL"
  fi

  echo "Got TR069 URL=$DYNAMIC_URL USER=$DYNAMIC_USER PASS=$DYNAMIC_PASS"
  logger -t udhcpc "Got TR069 URL=$DYNAMIC_URL USER=$DYNAMIC_USER PASS=$DYNAMIC_PASS"

  # Compare dynamic URL from DHCP with what we have since previously
  # and store the values if they have changed.
  STORED_URL=$(/sbin/uci get tr069_client.management_server.url)
  STORED_USER=$(/sbin/uci get tr069_client.management_server.username)
  STORED_PASS=$(/sbin/uci get tr069_client.management_server.password)

  if [ "$STORED_URL" != "$DYNAMIC_URL" -o \
      "$STORED_USER" != "$DYNAMIC_USER" -o \
      "$STORED_PASS" != "$DYNAMIC_PASS" ]; then
    echo "TR069 URL has changed, storing new values"
    logger -t udhcpc "TR069 URL has changed, storing new values"
    /sbin/uci set tr069_client.management_server.url="$DYNAMIC_URL"
    /sbin/uci set tr069_client.management_server.username="$DYNAMIC_USER"
    /sbin/uci set tr069_client.management_server.password="$DYNAMIC_PASS"
  fi
}

voip_interface() {
    local voip_signal_dev;
    local voip_signal_if=`uci get sip.global.signal_interface`
    local voip_media_dev;
    local voip_media_if=`uci get sip.global.media_interface`
    [ -z "$voip_signal_if" ] && voip_signal_if=$(uci -q get network.default.wan_if)
    [ -z "$voip_media_if" ] &&  voip_media_if=$(uci -q get network.default.wan_if)
    [ -n "voip_signal_if" ] && {
        voip_signal_dev=`uci -P /var/state get network.${voip_signal_if}.ifname`
        [ -n "voip_signal_dev" -a "$voip_signal_dev" = "$1" ] && {
            #reload sipapp
            echo "sip.global.toggle=1" > /tmp/mafifo
            echo "sip.global.toggle=0" > /tmp/mafifo
        }
    }

    [ -n "voip_media_if" ] && {
        voip_media_dev=`uci -P /var/state get network.${voip_media_if}.ifname`
        [ -n "voip_media_dev" -a "$voip_media_dev" = "$1" ] && {
            #reload sipapp
            echo "sip.global.toggle=1" > /tmp/mafifo
            echo "sip.global.toggle=0" > /tmp/mafifo
        }
    }
}

case "$1" in
  deconfig)
    ifconfig $interface 0.0.0.0
    dbg_log "hotplug_event ifdown"
    hotplug_event ifdown "" "$1"
    dhcpc_remove_option3_gw "$interface"
    dhcpc_remove_nameservers "$interface"
    dhcpc_remove_option43 "$interface"
  ;;
  renew|bound)
    ori_ip=`ifconfig $interface|grep "inet addr"|cut -f 2 -d : |cut -f 1 -d " "`
    if [ "$ori_ip" = "$ip" ]; then
        ip_modified=no
    else
        ip_modified=yes
    fi
    ifconfig $interface $ip netmask ${subnet:-255.255.255.0} broadcast ${broadcast:-+}

    #parse option 125
    local VIvi="$option125"
    local opt125_ent_genexis_subopt1_data
    local tmp_len tmp_data
    local opt125_ent_code_len            opt125_ent_code
    local opt125_ent_subopt_code_len     opt125_ent_subopt_code
    local opt125_ent_subopt_datalen_len  opt125_ent_subopt_datalen
    local opt125_ent_subopt_data_len     opt125_ent_subopt_data

echo "option125    : $option125"

    while [ -n "$VIvi" ]
    do
#      VIvi="${VIvi/:/-}"
#      echo "VIvi    :   $VIvi"

      #start to get ent code
      tmp_len=`expr index "$VIvi" :`
      [ $tmp_len = 0 ] && break
      tmp_len=`expr $tmp_len - 1`
      opt125_ent_code_len=$tmp_len
      opt125_ent_code="${VIvi:0:$tmp_len}"
      echo "opt125_ent_code_len  : $opt125_ent_code_len"
      echo "opt125_ent_code      : $opt125_ent_code"

      #get remaining string----start from ent subopt code
      VIvi="${VIvi:$tmp_len}"
      VIvi="${VIvi:1}"

      #start to get ent subopt code
      tmp_len=`expr index "$VIvi" :`
      [ $tmp_len = 0 ] && break
      tmp_len=`expr $tmp_len - 1`
      opt125_ent_subopt_code_len=$tmp_len
      opt125_ent_subopt_code="${VIvi:0:$tmp_len}"
      echo "opt125_ent_subopt_code_len    : $opt125_ent_subopt_code_len"
      echo "opt125_ent_subopt_code        : $opt125_ent_subopt_code"

      #get remaining string----start from ent subopt data len
      VIvi="${VIvi:$tmp_len}"
      VIvi="${VIvi:1}"

      #start to get ent subopt data length
      tmp_len=`expr index "$VIvi" :`
      [ $tmp_len = 0 ] && break
      tmp_len=`expr $tmp_len - 1`
      opt125_ent_subopt_datalen_len=$tmp_len
      opt125_ent_subopt_datalen="${VIvi:0:$tmp_len}"
      echo "opt125_ent_subopt_datalen_len : $opt125_ent_subopt_datalen_len"
      echo "opt125_ent_subopt_datalen     : $opt125_ent_subopt_datalen"

      #get remaining string----start from ent subopt data
      VIvi="${VIvi:$tmp_len}"
      VIvi="${VIvi:1}"

      #start to get ent subopt data
      #if length isn't enough, we break.
      tmp_len=`expr $opt125_ent_subopt_datalen`
      [ ${#VIvi} -lt $tmp_len ] && break
      opt125_ent_subopt_data_len=$tmp_len
      opt125_ent_subopt_data="${VIvi:0:$tmp_len}"
      echo "opt125_ent_subopt_data        : $opt125_ent_subopt_data"

      #check whether we have got ent code 'genexis' and subopt1
      [ "$opt125_ent_code" = "25167" -a "$opt125_ent_subopt_code" = "1" ] && {
        opt125_ent_genexis_subopt1_data="$opt125_ent_subopt_data"
        opt125_ent_genexis_number="25167"
        echo "opt125_ent_genexis_subopt1_data   : $opt125_ent_genexis_subopt1_data"
        break
      }

      #get remaining string----start from next ent code
      VIvi="${VIvi:$tmp_len}"
      VIvi="${VIvi:1}"
    done

    #parse option 212

    # Create leases path for the interface
    local leasepath="/tmp/leases"
#    local leaseif="${interface/eth0./vlan}"
    local leaseif="$interface"
    [ "${interface:0:4}" = "eth0" ] && {
      leaseif="vlan${interface:5}"
    }
    echo "interface  : $interface"
    echo "leaseif    : $leaseif"

    local leasefile1="$leasepath/$leaseif.1"
    local leasefile2="$leasepath/$leaseif.2"
    local leasefile3="$leasepath/$leaseif.3"

    [ -d "$leasepath" ] || mkdir $leasepath

    local mac=$(uci -q get network.$leaseif.macaddr)
    local macaddr="${mac:0:2}${mac:3:2}.${mac:6:2}${mac:9:2}.${mac:12:2}${mac:15:2}"
    local clientID="${mac:0:2}${mac:3:2}${mac:6:2}${mac:9:2}${mac:12:2}${mac:15:2}"

    local current=$(cat /proc/uptime)
    current=${current%%.*}
    echo "$current,$lease" > $leasefile2

    echo "      MAC Address : $macaddr"                                >  $leasefile1
    echo "       IP Address : $ip"                                     >> $leasefile1
    echo "  Vendor Class Id : $(cat /tmp/vendor_$leaseif 2>/dev/null)" >> $leasefile1
    echo "        Client-ID : $clientID"                               >> $leasefile1
    echo "        Server-ID : $serverid"                               >> $leasefile1
    echo "      Next Server : $siaddr"                                 >> $leasefile1
    echo "             File : $boot_file"                              >> $leasefile1

    echo "     DHCP Options :"                                         >  $leasefile3
    echo "       Option   1 : netmask $subnet"                         >> $leasefile3
    echo "       Option   3 : router $router"                          >> $leasefile3
    echo "       Option   6 : dns-server $dns"                         >> $leasefile3
    echo "       Option  12 : hostname $hostname"                      >> $leasefile3
    echo "       Option  15 : domain-name $domain"                     >> $leasefile3
    echo "       Option  28 : broadcast $broadcast"                    >> $leasefile3
    echo "       Option  42 : ntp-server $ntpsrv"                      >> $leasefile3
    echo "       Option  43 : vendor-info $vendorinfo"                 >> $leasefile3
    echo "       Option  51 : lease-time $lease"                       >> $leasefile3
    echo "       Option  66 : tftp-server $tftp"                       >> $leasefile3
    echo "       Option  67 : bootfile-name $bootfile"                 >> $leasefile3
    echo "       Option 119 : domain-search $search"                   >> $leasefile3
    echo "       Option 121 : classless-static-route $classlessroute"  >> $leasefile3
    # option 125
    if [ -n "$opt125_ent_genexis_number" ]; then
      echo "       Option 125 : V-I Vendor-specific Information:"      >> $leasefile3
      echo "                      enterprise number  : $opt125_ent_genexis_number(Genexis B.V.)">> $leasefile3
      echo "                        suboption 1 data : $opt125_ent_genexis_subopt1_data">> $leasefile3
    elif [ -n "$option125" ]; then
      echo "       Option 125 : V-I Vendor-specific Information: Unknown suboptions"   >> $leasefile3
    else
      echo "       Option 125 : V-I Vendor-specific Information:"      >> $leasefile3
    fi
    # option 212

    # Write options which are configured to be inherited to the file and signal
    # dnsmasq to refresh
    scan_interfaces

    source_interface=$(/sbin/uci -q get network.dhcpc.source_interface)
    config_get ifname $source_interface ifname
    [ "$ifname" == "$interface" ] && {
      local opt_numbers=$(/sbin/uci -q get network.dhcpc.dhcp_option)
      local opt_number
      local opt_type
      local opt_value
      local opt_desc

      # Open the file
      open_dhcp_opt_file

      # Add options to the file
      for number in $opt_numbers; do
        opt_number=${number%,*}
        opt_type=${number#*,}

        case $opt_number in
          "name-server")      opt_number="5";;
          "dns-server")       opt_number="6";;
          "swap-server")      opt_number="16";;
          "root-path")        opt_number="17";;
          "ntp-server")       opt_number="42";;
          "tftp-server-name") opt_number="66";;
          "bootfile-name")    opt_number="67";;
        esac

        opt_desc=""
        case $opt_number in
          "1")   opt_value="$subnet";;
          "2")   opt_value="$timezone";                        opt_desc="time-offset";;
          "3")   opt_value="$router";      opt_type="ip";;
          "4")   opt_value="$timesrv";     opt_type="ip";      opt_desc="time-server";;
          "5")   opt_value="$namesrv";     opt_type="ip";      opt_desc="name-server";;
          "6")   opt_value="$dns";         opt_type="ip";;
          "7")   opt_value="$logsrv";      opt_type="ip";      opt_desc="log-server.";;
          "8")   opt_value="$cookiesrv";   opt_type="ip";      opt_desc="cookie-server";;
          "9")   opt_value="$lprsrv";      opt_type="ip";      opt_desc="lpr-erver";;
          "12")  opt_value="$hostname";    opt_type="string";;
          "13")  opt_value="$bootsize";                        opt_desc="boot-file-size";;
          "15")  opt_value="$domain";      opt_type="string";;
          "16")  opt_value="$swapsrv";                         opt_desc="swap-server";;
          "17")  opt_value="$rootpath";    opt_type="string";  opt_desc="root-path";;
          "23")  opt_value="$ipttl";                           opt_desc="default-ttl";;
          "26")  opt_value="$mtu";                             opt_desc="mtu";;
          "28")  opt_value="$broadcast";;
          "40")  opt_value="$nisdomain";   opt_type="string";  opt_desc="nis-domain";;
          "41")  opt_value="$nissrv";      opt_type="ip";      opt_desc="nis-server";;
          "42")  opt_value="$ntpsrv";      opt_type="ip";;
          "43")  opt_value="$vendorinfo";  opt_type="string";;
          "44")  opt_value="$wins";        opt_type="ip";      opt_desc="netbios-ns";;
          "50")  opt_value="$requestip";                       opt_desc="requested-address";;
          "51")  opt_value="$lease";;
          "53")  opt_value="$dhcptype";                        opt_desc="message-type";;
          "54")  opt_value="$serverid";;
          "56")  opt_value="$message";     opt_type="string";  opt_desc="message";;
          "60")  opt_value="$vendorclass"; opt_type="string";  opt_desc="vendor-class";;
          "61")  opt_value="$clientid";    opt_type="string";  opt_desc="client-id";;
          "66")  opt_value="$tftp";        opt_type="string";;
          "67")  opt_value="$bootfile";    opt_type="string";;
          "77")  opt_value="$userclass";   opt_type="string";;
          "119") opt_value="$search";      opt_type="string";  opt_desc="domain-search";;
          "121") opt_value="$classlessroute";;
          "252") opt_value="$wpad";        opt_type="string";  opt_desc="wpad";;
          *) eval opt_value="$""option"$opt_number;            opt_desc="private-option";;
        esac

        # Add a supported option only
        [ -n "$opt_number" -a -n "$opt_value" ] && {
          if [ "$opt_type" = "string" ]; then
            # add quota on string to let dnsmasq recognize,
            # but don't chang the value
            add_dhcp_opt_str "$opt_number" "$opt_value"
          elif [ "$opt_type" = "ip" ]; then
            add_dhcp_opt_ip "$opt_number" "$opt_value"
          else
            add_dhcp_opt "$opt_number" "$opt_value"
          fi
        }

        # record to leases file
        [ -n "$opt_desc" ] && {
            if [ "$opt_number" -lt 10 ]; then
                echo "       Option   $opt_number : $opt_desc $opt_value" >> $leasefile3
            elif [ "$opt_number" -lt 100 ]; then
                echo "       Option  $opt_number : $opt_desc $opt_value"  >> $leasefile3
            else
                echo "       Option $opt_number : $opt_desc $opt_value"   >> $leasefile3
            fi
        }
      done

      # Close the file and signal dnsmasq to refresh
      close_dhcp_opt_file
    }

    # bug #21748 if default config does not have route.mgmt_src_if, 
    # then default mgmt intf is network.default.wan_if
    mgmt_if=`uci get route.mgmt_src_if 2> /dev/null`
    [ -z "$mgmt_if" ] && {
      mgmt_if=`uci get network.default.wan_if 2> /dev/null`
    }

    [ -n "$mgmt_if" ] && mgmt_dev=`cli_intf2dev $mgmt_if`

    # set metric lower if management interface
    met=1
    [ "$interface" = "$mgmt_dev" ] && met=0

    [ -n "$classlessroute" ] && {
        local default_route=""

        touch $DHCPC_ROUTE_ADD_FILE
        touch $DHCPC_ROUTE_DEL_FILE
        touch $DHCPC_ROUTE_TEMP_FILE

        for param in $classlessroute; do
            rt_dest=${param%,*}
            rt_gway=${param#*,}

            if [ "$rt_dest" = "0.0.0.0/0" ]; then
                # store default route(s)
                default_route="$default_route $rt_gway"
            else
                # add unexistence route(s) to a file
                dhcpc_add_new_routes "$rt_dest" "$rt_gway" "$interface" "$met"
            fi
        done

        # del old default route(s)
        dhcpc_remove_default_gw_no_route_fixup "$interface" "$default_route" "$met"

        # add new default route(s)
        for i in $default_route ; do
            ret=`route add default gw $i dev $interface metric $met`
            echo "gw $i dev $interface metric $met" >> $DHCPC_ROUTE_DEFAULT_FILE
        done

        # add unused existence route(s) to a file
        dhcpc_del_old_routes

        # add new route(s), del old route(s)
        dhcpc_reload_routes

        rm -f $DHCPC_ROUTE_ADD_FILE
        rm -f $DHCPC_ROUTE_DEL_FILE
        rm -f $DHCPC_ROUTE_HISTORY_FILE
        cp $DHCPC_ROUTE_TEMP_FILE $DHCPC_ROUTE_HISTORY_FILE
        rm -f $DHCPC_ROUTE_TEMP_FILE
    }

    [ -z "$classlessroute" ] && {
    [ -n "$router" ] && {
      # future: met=`/sbin/uci get network."$interface".metric 2> /dev/null` ; the interface name will have to be xlated
      # remove old routes using file cached gw, dev and met
      dhcpc_remove_default_gw_no_route_fixup "$interface" "$router" "$met"

      # add default gateway(s) from dhcp option
      for i in $router ; do
        dbg_log "route add default gw $i dev $interface metric $met"
        ret=`route add default gw $i dev $interface metric $met`
        # other parts of code are dependant on this format; see dhcpc_remove_default_gw_no_route_fixup
        echo "gw $i dev $interface metric $met" >> $DHCPC_ROUTE_DEFAULT_FILE
      done

    }
    }

    # do not use dhcp obtained name servers if static config exist
    if [ -n "$dns" ] ; then
      local num_inserts=0
      echo -n > "$RESOLV_CONF_DHCPC_TMP_HIS"
      # insert option 15 domain as search path
      ${domain:+echo search $domain} >> "$RESOLV_CONF_DHCPC_TMP_HIS"
      # insert option 119 search as domain
      ${search:+echo domain $search} >> "$RESOLV_CONF_DHCPC_TMP_HIS"
      # insert name servers
      for ii in $dns ; do
        echo "nameserver $ii" >> "$RESOLV_CONF_DHCPC_TMP_HIS"
        # max allowed is 2 name-servers per interface
        let num_inserts=num_inserts+1
        [ "$num_inserts" -ge 2 ] && break;
      done

      # rebuild name server list if this lease info has changed
      dhcp_ns_rebuild=1
      [ -f $RESOLV_CONF_DHCPC_TMP ] && {
          dhcp_ns_rebuild=0
	  if ! cmp -s $RESOLV_CONF_DHCPC_TMP $RESOLV_CONF_DHCPC_TMP_HIS; then
	    dhcp_ns_rebuild=1
	  fi
      }
      [ "$dhcp_ns_rebuild" -ne 0 ] && {
         cp -f $RESOLV_CONF_DHCPC_TMP_HIS $RESOLV_CONF_DHCPC_TMP > /dev/null
         #re-evaluate dnsmasq dynamic settings
         . /bin/dns_eval.sh
         dns_evaluate "dhcp-$interface"
      }
    else
      # if this lease has no name servers, then remove any history related
      dhcpc_remove_nameservers "$interface"
    fi
    rm -f $RESOLV_CONF_DHCPC_TMP_HIS > /dev/null

    # option 43 gaps server vendor info process
    [ "$interface" = "$mgmt_dev" ] && {
      opt_s=""
      opt_c=""
      opt_v=""
      opt_m="0"
      bad_opt=0;
      if [ -n "$opt125_ent_genexis_subopt1_data" ] ; then
        # bug 25492 replace argument 'space' with ~SPACE~ so the for loop works, and space accepted in content
        ven="${opt125_ent_genexis_subopt1_data// /~SPACE~}"
        # replace ; with space for loop
        ven="${ven//;/ }"
        for ii in $ven ; do
            Toption=${ii%=*}
            Tcontent=${ii#*=}
            if [ "$Toption" == "s" ]; then
               opt_s="$Tcontent"
            elif [ "$Toption" == "v" ]; then
               opt_v="$Tcontent"
               if [[ $opt_v == *[[:alpha:]]* ]]; then
                  bad_opt=1
                  logger -p local4.error "gaps: dhcp char in vlan tag=$opt_v"
                  opt_v=""
                  opt_s=""
               elif [[ $opt_v -gt 4094 ]]; then
                  bad_opt=1
                  logger -p local4.error "gaps: dhcp vlan>4094 tag=$opt_v"
                  opt_v=""
                  opt_s=""
               elif [[ $opt_v -lt 0 ]]; then
                  bad_opt=1
                  logger -p local4.error "gaps: dhcp vlan<0 tag=$opt_v"
                  opt_v=""
                  opt_s=""
               fi
            elif [ "$Toption" == "m" ]; then
               opt_m="$Tcontent"
            elif [ "$Toption" == "c" ]; then
               opt_c="$Tcontent"
            else
               logger -p local4.notice "gaps: dhcp param '$Toption=$Tcontent' unknown"
            fi
            [ "$bad_opt" -ne 0 ] && break;              
        done
      fi
      # change occur?
      echo "s=$opt_s;v=$opt_v;c=$opt_c" > "$VENDOR_INFO_CURRENT"
      gaps_changed=1
      [ -f $VENDOR_INFO_HISTORY ] && {
         gaps_changed=0
  	     if ! cmp -s $VENDOR_INFO_CURRENT $VENDOR_INFO_HISTORY; then
  	        gaps_changed=1
         fi
      }
      [ "$ip_modified" = "yes" ] && [ "$gaps_changed" -eq 0 ] && {
         gaps_changed=1
         logger -p local4.notice "gaps: ip address changed"
      }
      [ "$gaps_changed" -ne 0 ] && {
         cp -f $VENDOR_INFO_CURRENT $VENDOR_INFO_HISTORY
         echo "gaps.client.id=$opt_c"   > /tmp/mafifo
         echo "gaps.client.mode=$opt_m" > /tmp/mafifo
         echo "gaps.client.vlan=$opt_v" > /tmp/mafifo
         echo "gaps.server.host=$opt_s" > /tmp/mafifo
         logger -p local4.notice "gaps: if=$mgmt_dev dhcp-opts s=$opt_s;v=$opt_v;c=$opt_c"
      }
    }

    cur_logsrv=`ps  |grep syslogd |awk -F"-R" '{print $2}' |awk '{print $1}'`
    [ "$cur_logsrv" != "$logsrv" ] && /etc/rc.d/S??syslogd restart "$logsrv"

    [ -n "$hostname" ] && which hostname >/dev/null && hostname "$hostname"

    [ -n "$domain" ] && which domainname >/dev/null && domainname "$domain"

    # Note: tftp/bootfile come from option 66/67 and are used
    #       for firmware upgrade
    #       sname/boot_file come from sname/filename in the dhcp
    #       header and are used for config download

    # firmware upgrade
    f_url=`to_url $bootfile $tftp`
    [ -z "$f_url" ] || firmware_upgrade $f_url

    # config download
    c_url=`to_url $boot_file $siaddr $sname`
    [ -z "$c_url" ] || config_download $c_url

    # TR-069 ACS URL
    [ -n "$vendorinfo" ] && tr069_url

    if [ "$1" = "renew" ]; then
      if [ -n "$ntpsrv" ] ; then
        hotplug_event update "$ntpsrv" "$1"
      else
        hotplug_event update "" "$1"
      fi
    else
      if [ -n "$ntpsrv" ] ; then
        hotplug_event ifup "$ntpsrv" "$1"
      else
        hotplug_event ifup "" "$1"
      fi
    fi

    [ "$1" = "bound" -a "$ip_modified" = "yes" ] && voip_interface "$interface"

    # user rules
    [ -f /etc/udhcpc.user ] && . /etc/udhcpc.user

  ;;
esac

exit 0
